//===========================================================================
// 
// Just another Warcraft III map
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Fri Mar 13 18:26:03 2015
//   Map Author: Unknown
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************

globals
    // Generated
    trigger                 gg_trg_Lab_Core            = null
    trigger                 gg_trg_Tutorial_0          = null
    trigger                 gg_trg_Lab_0               = null
    trigger                 gg_trg_Lab_1               = null
    trigger                 gg_trg_Lab_2               = null
    trigger                 gg_trg_Tutorial_1          = null
    trigger                 gg_trg_Lab_3               = null
    trigger                 gg_trg_Lab_4               = null
    trigger                 gg_trg_Tutorial_2          = null
    trigger                 gg_trg_Lab_5               = null
    trigger                 gg_trg_Tutorial_3          = null
    trigger                 gg_trg_Lab_6               = null
    trigger                 gg_trg_Tutorial_4          = null
    trigger                 gg_trg_Lab_7               = null
    trigger                 gg_trg_Tutorial_5          = null
    trigger                 gg_trg_Lab_8               = null
    trigger                 gg_trg_Tutorial_6          = null
    trigger                 gg_trg_Lab_9               = null
    trigger                 gg_trg_Tutorial_7          = null
    trigger                 gg_trg_Lab_10              = null
    trigger                 gg_trg_Tutorial_8          = null
    trigger                 gg_trg_AllocQ              = null
    trigger                 gg_trg_AllocT              = null
    trigger                 gg_trg_ListNx              = null
    trigger                 gg_trg_NxStackT            = null
    trigger                 gg_trg_ListT               = null
    trigger                 gg_trg_Table               = null
    trigger                 gg_trg_NxStack             = null
    trigger                 gg_trg_NxListT             = null
    trigger                 gg_trg_UniqueNxListT       = null
    trigger                 gg_trg_WorldBounds         = null
    trigger                 gg_trg_ErrorMessage        = null
    trigger                 gg_trg_Init                = null
    trigger                 gg_trg_TableField          = null
    trigger                 gg_trg_Trigger_Refresh     = null
    trigger                 gg_trg_BooleanExpression   = null
    trigger                 gg_trg_Trigger             = null
    trigger                 gg_trg_UnitIndexer_Settings = null
    trigger                 gg_trg_UnitIndexer         = null
    trigger                 gg_trg_UnitIndexer_UnitIndex = null
    trigger                 gg_trg_UnitIndexer_UnitIndexer = null
    trigger                 gg_trg_UnitIndexer_Pregame_Event = null
    trigger                 gg_trg_Advanced            = null
    trigger                 gg_trg_attack_indexing     = null
    trigger                 gg_trg_test                = null
    trigger                 gg_trg_DDS                 = null
    trigger                 gg_trg_Damage_Event_DDS_Plugin = null
    trigger                 gg_trg_Damage_Event_Modification_DDS_Plugin = null
    trigger                 gg_trg_Damage_Event_Archetype_DDS_Plugin = null
    trigger                 gg_trg_Type                = null
    trigger                 gg_trg_API_Demonstration   = null
    trigger                 gg_trg_Display             = null
    trigger                 gg_trg_Reliability         = null
    trigger                 gg_trg_Lifebar_Flicker     = null
    trigger                 gg_trg_Benchmark           = null
    trigger                 gg_trg_GUI_API             = null
    trigger                 gg_trg_API_Demonstration_GUI = null
    trigger                 gg_trg_API_Demonstration_GUI_1 = null
    trigger                 gg_trg_API_Demonstration_GUI_2 = null
    trigger                 gg_trg_API_Demonstration_GUI_3 = null
    trigger                 gg_trg_GUI_Priority_Registration = null
endglobals

function InitGlobals takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'Hmkg', 1095.5, 931.7, 4.780 )
    call SetHeroLevel( u, 9, false )
    call SetHeroStr( u, 4800, true )
    call SetHeroAgi( u, 2300, true )
    call SetHeroInt( u, 2700, true )
    set life = GetUnitState( u, UNIT_STATE_LIFE )
    call SetUnitState( u, UNIT_STATE_LIFE, 0.06 * life )
    call SelectHeroSkill( u, 'AHtb' )
    call SelectHeroSkill( u, 'AHtb' )
    call SelectHeroSkill( u, 'AHtb' )
    call SelectHeroSkill( u, 'AHtc' )
    call SelectHeroSkill( u, 'AHtc' )
    call SelectHeroSkill( u, 'AHtc' )
    call SelectHeroSkill( u, 'AHbh' )
    call SelectHeroSkill( u, 'AHbh' )
    call SelectHeroSkill( u, 'AHav' )
    set u = CreateUnit( p, 'Udea', 1403.5, 754.7, 154.400 )
    call SetHeroLevel( u, 9, false )
    call SetHeroStr( u, 44, true )
    call SetHeroAgi( u, 24000, true )
    call SetHeroInt( u, 31000, true )
    call SetUnitState( u, UNIT_STATE_MANA, 345 )
    call SelectHeroSkill( u, 'AUdc' )
    call SelectHeroSkill( u, 'AUdc' )
    call SelectHeroSkill( u, 'AUdc' )
    call SelectHeroSkill( u, 'AUdp' )
    call SelectHeroSkill( u, 'AUdp' )
    call SelectHeroSkill( u, 'AUdp' )
    call SelectHeroSkill( u, 'AUau' )
    call SelectHeroSkill( u, 'AUau' )
    call SelectHeroSkill( u, 'AUan' )
    set u = CreateUnit( p, 'Ewar', 1213.2, 534.8, 350.000 )
    call SetHeroLevel( u, 9, false )
    call SetHeroStr( u, 37000, true )
    call SetHeroAgi( u, 32, true )
    call SetHeroInt( u, 31000, true )
    call SelectHeroSkill( u, 'AEfk' )
    call SelectHeroSkill( u, 'AEfk' )
    call SelectHeroSkill( u, 'AEfk' )
    call SelectHeroSkill( u, 'AEbl' )
    call SelectHeroSkill( u, 'AEbl' )
    call SelectHeroSkill( u, 'AEbl' )
    call SelectHeroSkill( u, 'AEsh' )
    call SelectHeroSkill( u, 'AEsh' )
    call SelectHeroSkill( u, 'AEsv' )
    set u = CreateUnit( p, 'Nbrn', 1018.7, 556.1, 46.000 )
    call SetHeroLevel( u, 9, false )
    call SetHeroStr( u, 33000, true )
    call SetHeroAgi( u, 31, true )
    call SetHeroInt( u, 35000, true )
    call SelectHeroSkill( u, 'ANsi' )
    call SelectHeroSkill( u, 'ANsi' )
    call SelectHeroSkill( u, 'ANsi' )
    call SelectHeroSkill( u, 'ANba' )
    call SelectHeroSkill( u, 'ANba' )
    call IssueImmediateOrder( u, "blackarrowoff" )
    call SelectHeroSkill( u, 'ANdr' )
    call SelectHeroSkill( u, 'ANdr' )
    call SelectHeroSkill( u, 'ANdr' )
    call SelectHeroSkill( u, 'ANch' )
    set u = CreateUnit( p, 'Nbrn', 1056.6, 419.2, 46.000 )
    call SetHeroLevel( u, 9, false )
    call SelectHeroSkill( u, 'ANsi' )
    call SelectHeroSkill( u, 'ANsi' )
    call SelectHeroSkill( u, 'ANsi' )
    call SelectHeroSkill( u, 'ANba' )
    call SelectHeroSkill( u, 'ANba' )
    call IssueImmediateOrder( u, "blackarrowoff" )
    call SelectHeroSkill( u, 'ANdr' )
    call SelectHeroSkill( u, 'ANdr' )
    call SelectHeroSkill( u, 'ANdr' )
    call SelectHeroSkill( u, 'ANch' )
endfunction

//===========================================================================
function CreateBuildingsForPlayer1 takes nothing returns nothing
    local player p = Player(1)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'hctw', 2176.0, 3200.0, 270.000 )
    set u = CreateUnit( p, 'hctw', 1536.0, 3584.0, 270.000 )
    set u = CreateUnit( p, 'hctw', 960.0, 3136.0, 270.000 )
    set u = CreateUnit( p, 'hgtw', 1024.0, 3584.0, 270.000 )
    set u = CreateUnit( p, 'hgtw', 2112.0, 3584.0, 270.000 )
endfunction

//===========================================================================
function CreateUnitsForPlayer1 takes nothing returns nothing
    local player p = Player(1)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'hfoo', 1262.1, 3152.5, 21.578 )
    set u = CreateUnit( p, 'hfoo', 1417.0, 3159.1, 295.157 )
    set u = CreateUnit( p, 'hfoo', 1603.2, 3150.3, 32.180 )
    set u = CreateUnit( p, 'hfoo', 1775.1, 3154.7, 357.462 )
    set u = CreateUnit( p, 'hfoo', 1351.1, 3175.6, 125.413 )
    set u = CreateUnit( p, 'hfoo', 1511.2, 3166.7, 294.629 )
    set u = CreateUnit( p, 'hfoo', 1705.4, 3153.4, 357.308 )
    set u = CreateUnit( p, 'hfoo', 1867.3, 3173.3, 299.233 )
    set u = CreateUnit( p, 'hrif', 1130.8, 3314.5, 351.353 )
    set u = CreateUnit( p, 'hrif', 1321.5, 3321.7, 172.600 )
    set u = CreateUnit( p, 'hrif', 1479.6, 3326.6, 187.015 )
    set u = CreateUnit( p, 'hrif', 1669.9, 3333.9, 234.631 )
    set u = CreateUnit( p, 'hrif', 1915.0, 3346.1, 337.752 )
    set u = CreateUnit( p, 'hmtm', 1326.6, 3494.0, 177.698 )
    set u = CreateUnit( p, 'hmtm', 1798.5, 3504.7, 128.720 )
    set u = CreateUnit( p, 'hmtm', 1205.2, 3502.0, 304.484 )
    set u = CreateUnit( p, 'hmtm', 1953.0, 3510.0, 167.041 )
    set u = CreateUnit( p, 'hmpr', 1935.7, 3643.0, 236.730 )
    set u = CreateUnit( p, 'hmpr', 1734.3, 3643.0, 42.958 )
    set u = CreateUnit( p, 'hmpr', 1329.4, 3645.9, 31.290 )
    set u = CreateUnit( p, 'hmpr', 1165.8, 3631.6, 298.178 )
    set u = CreateUnit( p, 'hmpr', 1666.7, 3467.7, 96.188 )
    set u = CreateUnit( p, 'hmpr', 1445.2, 3457.2, 5.845 )
    set u = CreateUnit( p, 'Otch', 1565.2, 3408.4, 77.140 )
    call SetHeroLevel( u, 10, false )
    call SelectHeroSkill( u, 'AOae' )
    call SelectHeroSkill( u, 'AOae' )
    call SelectHeroSkill( u, 'AOae' )
    call SelectHeroSkill( u, 'AOre' )
    call UnitAddItemToSlotById( u, 'lgdh', 0 )
    call UnitAddItemToSlotById( u, 'ward', 1 )
    call UnitAddItemToSlotById( u, 'sbch', 2 )
    call UnitAddItemToSlotById( u, 'brac', 3 )
    call UnitAddItemToSlotById( u, 'afac', 4 )
    call UnitAddItemToSlotById( u, 'kpin', 5 )
    set u = CreateUnit( p, 'uabo', 1736.3, 3038.7, 86.575 )
    set u = CreateUnit( p, 'uabo', 1406.0, 3040.8, 314.658 )
    set u = CreateUnit( p, 'unec', 1208.3, 3410.9, 356.385 )
    set u = CreateUnit( p, 'unec', 1811.6, 3421.1, 71.150 )
    set u = CreateUnit( p, 'unec', 2029.9, 3368.3, 132.961 )
    set u = CreateUnit( p, 'unec', 1051.6, 3353.5, 174.358 )
    set u = CreateUnit( p, 'emtg', 1569.6, 2992.1, 25.401 )
    set u = CreateUnit( p, 'Udre', -582.0, 782.9, 237.800 )
    call SetHeroLevel( u, 10, false )
    call SetHeroStr( u, 20, true )
    call SetHeroAgi( u, 16000, true )
    call SetHeroInt( u, 18, true )
    call SetUnitState( u, UNIT_STATE_MANA, 101 )
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
    call CreateBuildingsForPlayer1(  )
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0(  )
    call CreateUnitsForPlayer1(  )
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreatePlayerBuildings(  )
    call CreatePlayerUnits(  )
endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: AllocQ
//===========================================================================
library AllocQ /* v1.0.1.0
*************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage /*      https://github.com/nestharus/JASS/tree/master/jass/Systems/ErrorMessage
*
*************************************************************************************
*
*	Maximizes speed by reducing local variable declarations and removing
*   if-statement.
*
*   Uses a queue instead of a stack for recycler. Using a queue requires one
*   extra variable declaration.
*
*       set alloc = recycler[0]
*       set recycler[0] = recycler[alloc]
*
************************************************************************************
*
*	module AllocQFast
*
*		Fields
*		-------------------------
*
*			readonly boolean isAllocated
*
*		Methods
*		-------------------------
*
*			static method allocate takes nothing returns thistype
*			method deallocate takes nothing returns nothing
*
*			debug static method calculateMemoryUsage takes nothing returns integer
*			debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	module AllocQ
        /*
        *   stack
        */
		private static integer array recycler
        private static integer alloc
        private static integer last = 8191
        
        /*
        *   list of allocated memory
        */
        debug private static integer array allocatedNext
        debug private static integer array allocatedPrev
        
        /*
        *   free memory counter
        */
        debug private static integer usedMemory = 0
		
        /*
        *   allocation
        */
		static method allocate takes nothing returns thistype
			set alloc = recycler[0]
			
			debug call ThrowError(alloc == 0, "AllocQ", "allocate", "thistype", 0, "Overflow.")
            
            set recycler[0] = recycler[alloc]
            
            set recycler[alloc] = -1
            
            debug set usedMemory = usedMemory + 1
            
            debug set allocatedNext[alloc] = 0
            debug set allocatedPrev[alloc] = allocatedPrev[0]
            debug set allocatedNext[allocatedPrev[0]] = alloc
            debug set allocatedPrev[0] = alloc
			
			return alloc
		endmethod
		
		method deallocate takes nothing returns nothing
			debug call ThrowError(recycler[this] != -1, "AllocQ", "deallocate", "thistype", this, "Attempted To Deallocate Null Instance.")
			
			set recycler[last] = this
            set recycler[this] = 0
			set last = this
            
            debug set usedMemory = usedMemory - 1
            
            debug set allocatedNext[allocatedPrev[this]] = allocatedNext[this]
            debug set allocatedPrev[allocatedNext[this]] = allocatedPrev[this]
		endmethod
		
        /*
        *   analysis
        */
        method operator isAllocated takes nothing returns boolean
			return recycler[this] == -1
		endmethod
        
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				return usedMemory
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				local integer memoryCell = allocatedNext[0]
				local string memoryRepresentation = null
				
				loop
					exitwhen memoryCell == 0
                    
                    if (memoryRepresentation == null) then
                        set memoryRepresentation = I2S(memoryCell)
                    else
                        set memoryRepresentation = memoryRepresentation + ", " + I2S(memoryCell)
                    endif
                    
                    set memoryCell = allocatedNext[memoryCell]
                endloop
                    
				return memoryRepresentation
			endmethod
		endif
        
        /*
        *   initialization
        */
		private static method onInit takes nothing returns nothing
			local integer i = 0

			set recycler[8191] = 0 //so that the array doesn't reallocate over and over again
            
			loop
				set recycler[i] = i + 1
				
				exitwhen i == 8190
				set i = i + 1
			endloop
		endmethod
	endmodule
endlibrary//===========================================================================
// Trigger: AllocT
//===========================================================================
library AllocT /* v1.0.2.0
*************************************************************************************
*
*	*/uses/*
*
*		*/ ErrorMessage /*      https://github.com/nestharus/JASS/tree/master/jass/Systems/ErrorMessage
*		*/ Table		/*      http://www.hiveworkshop.com/forums/jass-resources-412/snippet-new-table-188084/
*
*************************************************************************************
*
*	Minimizes code generation and global variables while maintaining
*   excellent performance.
*
*   Uses hashtable instead of array, which drastically reduces performance
*   but uncaps the instance limit. Should use with table fields instead of
*   array fields.
*
*       local thistype this = recycler[0]
*
*       if (recycler[this] == 0) then
*           set recycler[0] = this + 1
*       else
*           set recycler[0] = recycler[this]
*       endif
*
************************************************************************************
*
*	module AllocT
*
*		static method allocate takes nothing returns thistype
*		method deallocate takes nothing returns nothing
*
*		readonly boolean isAllocated
*
*		debug static method calculateMemoryUsage takes nothing returns integer
*		debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	module AllocT
        /*
        *   stack
        */
		private static Table recycler
        
        /*
        *   list of allocated memory
        */
        debug private static Table allocatedNext
        debug private static Table allocatedPrev
        
        /*
        *   free memory counter
        */
        debug private static integer usedMemory = 0
		
        /*
        *   allocation
        */
		static method allocate takes nothing returns thistype
			local thistype this = recycler[0]
			
			debug call ThrowError(this < 0, "AllocT", "allocate", "thistype", 0, "Overflow.")
            
            if (recycler[this] == 0) then
                set recycler[0] = this + 1
            else
                set recycler[0] = recycler[this]
            endif
            
            set recycler[this] = -1
            
            debug set usedMemory = usedMemory + 1
            
            debug set allocatedNext[this] = 0
            debug set allocatedPrev[this] = allocatedPrev[0]
            debug set allocatedNext[allocatedPrev[0]] = this
            debug set allocatedPrev[0] = this
			
			return this
		endmethod
		
		method deallocate takes nothing returns nothing
			debug call ThrowError(recycler[this] != -1, "AllocT", "deallocate", "thistype", this, "Attempted To Deallocate Null Instance.")
			
			set recycler[this] = recycler[0]
			set recycler[0] = this
            
            debug set usedMemory = usedMemory - 1
            
            debug set allocatedNext[allocatedPrev[this]] = allocatedNext[this]
            debug set allocatedPrev[allocatedNext[this]] = allocatedPrev[this]
		endmethod
		
        /*
        *   analysis
        */
        method operator isAllocated takes nothing returns boolean
			return recycler[this] == -1
		endmethod
        
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				return usedMemory
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				local integer memoryCell = allocatedNext[0]
				local string memoryRepresentation = null
				
				loop
					exitwhen memoryCell == 0
                    
                    if (memoryRepresentation == null) then
                        set memoryRepresentation = I2S(memoryCell)
                    else
                        set memoryRepresentation = memoryRepresentation + ", " + I2S(memoryCell)
                    endif
                    
                    set memoryCell = allocatedNext[memoryCell]
                endloop
                    
				return memoryRepresentation
			endmethod
		endif
        
        /*
        *   initialization
        */
		private static method onInit takes nothing returns nothing
            set recycler = Table.create()
            debug set allocatedNext = Table.create()
            debug set allocatedPrev = Table.create()
            
			set recycler[0] = 1
		endmethod
	endmodule
endlibrary//===========================================================================
// Trigger: ListNx
//===========================================================================
library ListNx /* v1.0.0.2
************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage	/*
*
************************************************************************************
*
*	module ListNx
*
*		Description
*		-------------------------
*
*			Node Properties:
*
*				Unique
*				Not 0
*
*		Fields
*		-------------------------
*
*			readonly static integer sentinel
*
*			readonly static thistype first
*			readonly static thistype last
*
*			readonly thistype next
*			readonly thistype prev
*
*		Methods
*		-------------------------
*
*			static method push takes thistype node returns nothing
*			static method enqueue takes thistype node returns nothing
*
*			static method pop takes nothing returns nothing
*			static method dequeue takes nothing returns nothing
*
*			method remove takes nothing returns nothing
*
*			static method clear takes nothing returns nothing
*
************************************************************************************/
	module ListNx
		debug private boolean isNode
		
		private thistype _next
		method operator next takes nothing returns thistype
			debug call ThrowError(this == 0,	"StaticUniqueList", "next", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"StaticUniqueList", "next", "thistype", this, "Attempted To Read Invalid Node.")
			
			return _next
		endmethod
		
		private thistype _prev
		method operator prev takes nothing returns thistype
			debug call ThrowError(this == 0,	"StaticUniqueList", "prev", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"StaticUniqueList", "prev", "thistype", this, "Attempted To Read Invalid Node.")
			
			return _prev
		endmethod
		
		static method operator first takes nothing returns thistype
			return thistype(0)._next
		endmethod
		static method operator last takes nothing returns thistype
			return thistype(0)._prev
		endmethod
		
		private static method setFirst takes thistype node returns nothing
			set thistype(0)._next = node
		endmethod
		
		private static method setLast takes thistype node returns nothing
			set thistype(0)._prev = node
		endmethod
		
		static constant integer sentinel = 0
		
		static method push takes thistype node returns nothing
			debug call ThrowError(node == 0,	"StaticUniqueList", "push", "thistype", 0, "Attempted To Push Null Node.")
			debug call ThrowError(node.isNode,	"StaticUniqueList", "push", "thistype", 0, "Attempted To Push Owned Node (" + I2S(node) + ").")
			
			debug set node.isNode = true
			
			set first._prev = node
			set node._next = first
			call setFirst(node)
				
			set node._prev = 0
		endmethod
		static method enqueue takes thistype node returns nothing
			debug call ThrowError(node == 0,	"StaticUniqueList", "enqueue", "thistype", 0, "Attempted To Enqueue Null Node.")
			debug call ThrowError(node.isNode,	"StaticUniqueList", "enqueue", "thistype", 0, "Attempted To Enqueue Owned Node (" + I2S(node) + ").")
			
			debug set node.isNode = true
			
			set last._next = node
			set node._prev = last
			call setLast(node)
			
			set node._next = 0
		endmethod
		static method pop takes nothing returns nothing
			debug call ThrowError(first == 0,	"StaticUniqueList", "pop", "thistype", 0, "Attempted To Pop Empty List.")
			
			debug set first.isNode = false
			
			call setFirst(first._next)
			set first._prev = 0
		endmethod
		static method dequeue takes nothing returns nothing
			debug call ThrowError(last == 0,	"StaticUniqueList", "dequeue", "thistype", 0, "Attempted To Dequeue Empty List.")
			
			debug set last.isNode = false
			
			call setLast(last._prev)
			set last._next = 0
		endmethod
		method remove takes nothing returns nothing
			debug call ThrowError(this == 0,	"StaticUniqueList", "remove", "thistype", 0, "Attempted To Remove Null Node.")
			debug call ThrowError(not isNode,	"StaticUniqueList", "remove", "thistype", 0, "Attempted To Remove Invalid Node (" + I2S(this) + ").")
			
			debug set isNode = false
			
			set _prev._next = _next
			set _next._prev = _prev
		endmethod
		static method clear takes nothing returns nothing
			static if DEBUG_MODE then
				local thistype node = first
			
				loop
					exitwhen node == 0
					set node.isNode = false
					set node = node._next
				endloop
			endif
			
			call setFirst(0)
			call setLast(0)
		endmethod
	endmodule
endlibrary//===========================================================================
// Trigger: NxStackT
//===========================================================================
library NxStackT /* v1.0.0.2
************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage	/*
*		*/ TableField	/*
*
************************************************************************************
*
*	module NxStackT
*
*		Description
*		-------------------------
*
*			Collection Properties:
*
*				Unique to Collection
*				Allocated
*				Not 0
*
*		Fields
*		-------------------------
*
*			readonly static integer sentinel
*
*			readonly thistype first
*			readonly thistype next
*
*		Methods
*		-------------------------
*
*			method destroy takes nothing returns nothing
*
*			method push takes nothing returns thistype
*			method pop takes nothing returns nothing
*
*			method clear takes nothing returns nothing
*				-	Initializes stack, use instead of create
*
*			debug static method calculateMemoryUsage takes nothing returns integer
*			debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	private keyword isNode
	private keyword isCollection
	private keyword p_next
	private keyword p_first
	
	module NxStackT
		private static thistype nodeCount = 0
		
		static if DEBUG_MODE then
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "isNode", "boolean")
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "isCollection", "boolean")
		endif
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_next", "thistype")
		method operator next takes nothing returns thistype
			debug call ThrowError(this == 0,	"NxStack", "next", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"NxStack", "next", "thistype", this, "Attempted To Read Invalid Node.")
			return p_next
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_first", "thistype")
		method operator first takes nothing returns thistype
			debug call ThrowError(this == 0,		"NxStack", "first", "thistype", this, "Attempted To Read Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "first", "thistype", this, "Attempted To Read Invalid Stack.")
			return p_first
		endmethod
		
		static method operator sentinel takes nothing returns integer
			return 0
		endmethod
		
		private static method allocateNode takes nothing returns thistype
			local thistype this = thistype(0).p_next
			
			if (0 == this) then
				set this = nodeCount + 1
				set nodeCount = this
			else
				set thistype(0).p_next = p_next
			endif
			
			return this
		endmethod
		
		method push takes nothing returns thistype
			local thistype node = allocateNode()
			
			debug call ThrowError(this == 0,		"NxStack", "push", "thistype", this, "Attempted To Push On To Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "push", "thistype", this, "Attempted To Push On To Invalid Stack.")
			
			debug set node.isNode = true
			
			set node.p_next = p_first
			set p_first = node
			
			return node
		endmethod
		method pop takes nothing returns nothing
			local thistype node = p_first
			
			debug call ThrowError(this == 0,		"NxStack", "pop", "thistype", this, "Attempted To Pop Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "pop", "thistype", this, "Attempted To Pop Invalid Stack.")
			debug call ThrowError(node == 0,		"NxStack", "pop", "thistype", this, "Attempted To Pop Empty Stack.")
			
			debug set node.isNode = false
			
			set p_first = node.p_next
			
			set node.p_next = thistype(0).p_next
			set thistype(0).p_next = node
		endmethod
		private method getBottom takes nothing returns thistype
			set this = p_first
		
			loop
				exitwhen p_next == 0
				set this = p_next
			endloop
			
			return this
		endmethod
		method clear takes nothing returns nothing
			debug local thistype node = p_first
		
			debug call ThrowError(this == 0,		"NxStack", "clear", "thistype", this, "Attempted To Clear Null Stack.")
			
			debug if (not isCollection) then
				debug set isCollection = true
				
				debug set p_first = 0
				
				debug return
			debug endif
			
			static if DEBUG_MODE then
				loop
					exitwhen node == 0
					set node.isNode = false
					set node = node.p_next
				endloop
			endif
			
			if (p_first == 0) then
				return
			endif
			
			set getBottom().p_next = thistype(0).p_next
			set thistype(0).p_next = p_first
			set p_first = 0
		endmethod
		method destroy takes nothing returns nothing
			debug call ThrowError(this == 0,		"NxStack", "destroy", "thistype", this, "Attempted To Destroy Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "destroy", "thistype", this, "Attempted To Destroy Invalid Stack.")
			
			call clear()
				
			debug set isCollection = false
		endmethod
		
		private static method onInit takes nothing returns nothing
			static if DEBUG_MODE then
				//! runtextmacro INITIALIZE_TABLE_FIELD("isNode")
				//! runtextmacro INITIALIZE_TABLE_FIELD("isCollection")
			endif
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_next")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_first")
		endmethod
		
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				local thistype start = 1
				local thistype end = 8191
				local integer count = 0
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						return count + checkRegion(start, end)
					else
						set count = count + checkRegion(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return count
			endmethod
			
			private static method checkRegion takes thistype start, thistype end returns integer
				local integer count = 0
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						set count = count + 1
					endif
					if (start.isCollection) then
						set count = count + 1
					endif
					set start = start + 1
				endloop
				
				return count
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				local thistype start = 1
				local thistype end = 8191
				local string memory = null
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						set memory = memory + checkRegion2(start, end)
						set start = end + 1
					else
						set memory = memory + checkRegion2(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return memory
			endmethod
			
			private static method checkRegion2 takes thistype start, thistype end returns string
				local string memory = null
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "N"
						endif
					endif
					if (start.isCollection) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "C"
						endif
					endif
					set start = start + 1
				endloop
				
				return memory
			endmethod
		endif
	endmodule
endlibrary//===========================================================================
// Trigger: ListT
//===========================================================================
library ListT /* v1.0.0.3
************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage	/*
*
************************************************************************************
*
*	module ListT
*
*		Description
*		-------------------------
*
*			NA
*
*		Fields
*		-------------------------
*
*			readonly static integer sentinel
*
*			readonly thistype list
*
*			readonly thistype first
*			readonly thistype last
*
*			readonly thistype next
*			readonly thistype prev
*
*		Methods
*		-------------------------
*
*			static method create takes nothing returns thistype
*			method destroy takes nothing returns nothing
*				-	May only destroy lists
*
*			method push takes nothing returns thistype
*			method enqueue takes nothing returns thistype
*
*			method pop takes nothing returns nothing
*			method dequeue takes nothing returns nothing
*
*			method remove takes nothing returns nothing
*
*			method clear takes nothing returns nothing
*
*			debug static method calculateMemoryUsage takes nothing returns integer
*			debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	private keyword isNode
	private keyword isCollection
	private keyword pp_list
	private keyword pp_next
	private keyword pp_prev
	private keyword pp_first
	private keyword pp_last

	module ListT
		private static thistype collectionCount = 0
		private static thistype nodeCount = 0
		
		debug private static Table p_isNode
		debug method operator isNode takes nothing returns boolean
			debug return p_isNode.boolean[this]
		debug endmethod
		debug method operator isNode= takes boolean value returns nothing
			debug set p_isNode.boolean[this] = value
		debug endmethod
		
		debug private static Table p_isCollection
		debug method operator isCollection takes nothing returns boolean
			debug return p_isCollection.boolean[this]
		debug endmethod
		debug method operator isCollection= takes boolean value returns nothing
			debug set p_isCollection.boolean[this] = value
		debug endmethod
		
		private static Table p_list
		method operator pp_list takes nothing returns thistype
			return p_list[this]
		endmethod
		method operator pp_list= takes thistype value returns nothing
			set p_list[this] = value
		endmethod
		method operator list takes nothing returns thistype
			debug call ThrowError(this == 0,	"List", "list", "thistype", this, "Attempted To Read Null Node.")
			debug call ThrowError(not isNode,	"List", "list", "thistype", this, "Attempted To Read Invalid Node.")
			return pp_list
		endmethod
		
		private static Table p_next
		method operator pp_next takes nothing returns thistype
			return p_next[this]
		endmethod
		method operator pp_next= takes thistype value returns nothing
			set p_next[this] = value
		endmethod
		method operator next takes nothing returns thistype
			debug call ThrowError(this == 0,	"List", "next", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"List", "next", "thistype", this, "Attempted To Read Invalid Node.")
			return pp_next
		endmethod
		
		private static Table p_prev
		method operator pp_prev takes nothing returns thistype
			return p_prev[this]
		endmethod
		method operator pp_prev= takes thistype value returns nothing
			set p_prev[this] = value
		endmethod
		method operator prev takes nothing returns thistype
			debug call ThrowError(this == 0,	"List", "prev", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"List", "prev", "thistype", this, "Attempted To Read Invalid Node.")
			return pp_prev
		endmethod
		
		private static Table p_first
		method operator pp_first takes nothing returns thistype
			return p_first[this]
		endmethod
		method operator pp_first= takes thistype value returns nothing
			set p_first[this] = value
		endmethod
		method operator first takes nothing returns thistype
			debug call ThrowError(this == 0,		"List", "first", "thistype", this, "Attempted To Read Null List.")
			debug call ThrowError(not isCollection,	"List", "first", "thistype", this, "Attempted To Read Invalid List.")
			return pp_first
		endmethod
		
		private static Table p_last
		method operator pp_last takes nothing returns thistype
			return p_last[this]
		endmethod
		method operator pp_last= takes thistype value returns nothing
			set p_last[this] = value
		endmethod
		method operator last takes nothing returns thistype
			debug call ThrowError(this == 0,		"List", "last", "thistype", this, "Attempted To Read Null List.")
			debug call ThrowError(not isCollection,	"List", "last", "thistype", this, "Attempted To Read Invalid List.")
			return pp_last
		endmethod
		
		static method operator sentinel takes nothing returns integer
			return 0
		endmethod
		
		private static method allocateCollection takes nothing returns thistype
			local thistype this = thistype(0).pp_first
			
			if (0 == this) then
				debug call ThrowError(collectionCount == 8191, "List", "allocateCollection", "thistype", 0, "Overflow.")
				
				set this = collectionCount + 1
				set collectionCount = this
			else
				set thistype(0).pp_first = pp_first
			endif
			
			return this
		endmethod
		
		private static method allocateNode takes nothing returns thistype
			local thistype this = thistype(0).pp_next
			
			if (0 == this) then
				debug call ThrowError(nodeCount == 8191, "List", "allocateNode", "thistype", 0, "Overflow.")
				
				set this = nodeCount + 1
				set nodeCount = this
			else
				set thistype(0).pp_next = pp_next
			endif
			
			return this
		endmethod
		
		static method create takes nothing returns thistype
			local thistype this = allocateCollection()
			
			debug set isCollection = true
			
			set pp_first = 0
			
			return this
		endmethod
		method push takes nothing returns thistype
			local thistype node = allocateNode()
			
			debug call ThrowError(this == 0,		"List", "push", "thistype", this, "Attempted To Push On To Null List.")
			debug call ThrowError(not isCollection,	"List", "push", "thistype", this, "Attempted To Push On To Invalid List.")
			
			debug set node.isNode = true
			
			set node.pp_list = this
		
			if (pp_first == 0) then
				set pp_first = node
				set pp_last = node
				set node.pp_next = 0
			else
				set pp_first.pp_prev = node
				set node.pp_next = pp_first
				set pp_first = node
			endif
			
			set node.pp_prev = 0
			
			return node
		endmethod
		method enqueue takes nothing returns thistype
			local thistype node = allocateNode()
			
			debug call ThrowError(this == 0,		"List", "enqueue", "thistype", this, "Attempted To Enqueue On To Null List.")
			debug call ThrowError(not isCollection,	"List", "enqueue", "thistype", this, "Attempted To Enqueue On To Invalid List.")
			
			debug set node.isNode = true
			
			set node.pp_list = this
		
			if (pp_first == 0) then
				set pp_first = node
				set pp_last = node
				set node.pp_prev = 0
			else
				set pp_last.pp_next = node
				set node.pp_prev = pp_last
				set pp_last = node
			endif
			
			set node.pp_next = 0
			
			return node
		endmethod
		method pop takes nothing returns nothing
			local thistype node = pp_first
			
			debug call ThrowError(this == 0,		"List", "pop", "thistype", this, "Attempted To Pop Null List.")
			debug call ThrowError(not isCollection,	"List", "pop", "thistype", this, "Attempted To Pop Invalid List.")
			debug call ThrowError(node == 0,		"List", "pop", "thistype", this, "Attempted To Pop Empty List.")
			
			debug set node.isNode = false
			
			set pp_first.pp_list = 0
			
			set pp_first = pp_first.pp_next
			if (pp_first == 0) then
				set pp_last = 0
			else
				set pp_first.pp_prev = 0
			endif
			
			set node.pp_next = thistype(0).pp_next
			set thistype(0).pp_next = node
		endmethod
		method dequeue takes nothing returns nothing
			local thistype node = pp_last
			
			debug call ThrowError(this == 0,		"List", "dequeue", "thistype", this, "Attempted To Dequeue Null List.")
			debug call ThrowError(not isCollection,	"List", "dequeue", "thistype", this, "Attempted To Dequeue Invalid List.")
			debug call ThrowError(node == 0,		"List", "dequeue", "thistype", this, "Attempted To Dequeue Empty List.")
			
			debug set node.isNode = false
			
			set pp_last.pp_list = 0
		
			set pp_last = pp_last.pp_prev
			if (pp_last == 0) then
				set pp_first = 0
			else
				set pp_last.pp_next = 0
			endif
			
			set node.pp_next = thistype(0).pp_next
			set thistype(0).pp_next = node
		endmethod
		method remove takes nothing returns nothing
			local thistype node = this
			set this = node.pp_list
			
			debug call ThrowError(node == 0,		"List", "remove", "thistype", this, "Attempted To Remove Null Node.")
			debug call ThrowError(not node.isNode,	"List", "remove", "thistype", this, "Attempted To Remove Invalid Node (" + I2S(node) + ").")
			
			debug set node.isNode = false
			
			set node.pp_list = 0
		
			if (0 == node.pp_prev) then
				set pp_first = node.pp_next
			else
				set node.pp_prev.pp_next = node.pp_next
			endif
			if (0 == node.pp_next) then
				set pp_last = node.pp_prev
			else
				set node.pp_next.pp_prev = node.pp_prev
			endif
			
			set node.pp_next = thistype(0).pp_next
			set thistype(0).pp_next = node
		endmethod
		method clear takes nothing returns nothing
			debug local thistype node = pp_first
		
			debug call ThrowError(this == 0,		"List", "clear", "thistype", this, "Attempted To Clear Null List.")
			debug call ThrowError(not isCollection,	"List", "clear", "thistype", this, "Attempted To Clear Invalid List.")
			
			static if DEBUG_MODE then
				loop
					exitwhen node == 0
					set node.isNode = false
					set node = node.pp_next
				endloop
			endif
			
			if (pp_first == 0) then
				return
			endif
			
			set pp_last.pp_next = thistype(0).pp_next
			set thistype(0).pp_next = pp_first
			
			set pp_first = 0
			set pp_last = 0
		endmethod
		method destroy takes nothing returns nothing
			debug call ThrowError(this == 0,		"List", "destroy", "thistype", this, "Attempted To Destroy Null List.")
			debug call ThrowError(not isCollection,	"List", "destroy", "thistype", this, "Attempted To Destroy Invalid List.")
			
			static if DEBUG_MODE then
				debug call clear()
				
				debug set isCollection = false
			else
				if (pp_first != 0) then
					set pp_last.pp_next = thistype(0).pp_next
					set thistype(0).pp_next = pp_first
					
					set pp_last = 0
				endif
			endif
			
			set pp_first = thistype(0).pp_first
			set thistype(0).pp_first = this
		endmethod
		
		private static method onInit takes nothing returns nothing
			static if DEBUG_MODE then
				set p_isNode = Table.create()
				set p_isCollection = Table.create()
			endif
			set p_list = Table.create()
			set p_next = Table.create()
			set p_prev = Table.create()
			set p_first = Table.create()
			set p_last = Table.create()
		endmethod
		
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				local thistype start = 1
				local thistype end = 8191
				local integer count = 0
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						return count + checkRegion(start, end)
					else
						set count = count + checkRegion(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return count
			endmethod
			
			private static method checkRegion takes thistype start, thistype end returns integer
				local integer count = 0
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						set count = count + 1
					endif
					if (start.isCollection) then
						set count = count + 1
					endif
					set start = start + 1
				endloop
				
				return count
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				local thistype start = 1
				local thistype end = 8191
				local string memory = null
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						if (memory != null) then
							set memory = memory + ", "
						endif
						set memory = memory + checkRegion2(start, end)
						set start = end + 1
					else
						if (memory != null) then
							set memory = memory + ", "
						endif
						set memory = memory + checkRegion2(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return memory
			endmethod
			
			private static method checkRegion2 takes thistype start, thistype end returns string
				local string memory = null
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "N"
						endif
					endif
					if (start.isCollection) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "C"
						endif
					endif
					set start = start + 1
				endloop
				
				return memory
			endmethod
		endif
	endmodule
endlibrary//===========================================================================
// Trigger: Table
//===========================================================================
library Table /* made by Bribe, special thanks to Vexorian & Nestharus, version 3.1.0.3
    
    One map, one hashtable. Welcome to NewTable 3.2
    
    This library was originally called NewTable so it didn't conflict with
    the API of Table by Vexorian. However, the damage is done and it's too
    late to change the library name now. To help with damage control, I
    have provided an extension library called TableBC, which bridges all
    the functionality of Vexorian's Table except for 2-D string arrays &
    the ".flush(integer)" method. I use ".flush()" to flush a child hash-
    table, because I wanted the API in NewTable to reflect the API of real
    hashtables (I thought this would be more intuitive).
    
    API
    
    ------------
    struct Table
    | static method create takes nothing returns Table
    |     create a new Table
    |    
    | method destroy takes nothing returns nothing
    |     destroy it
    |    
    | method flush takes nothing returns nothing
    |     flush all stored values inside of it
    |    
    | method remove takes integer key returns nothing
    |     remove the value at index "key"
    |    
    | method operator []= takes integer key, $TYPE$ value returns nothing
    |     assign "value" to index "key"
    |    
    | method operator [] takes integer key returns $TYPE$
    |     load the value at index "key"
    |    
    | method has takes integer key returns boolean
    |     whether or not the key was assigned
    |
    ----------------
    struct TableArray
    | static method operator [] takes integer array_size returns TableArray
    |     create a new array of Tables of size "array_size"
    |
    | method destroy takes nothing returns nothing
    |     destroy it
    |
    | method flush takes nothing returns nothing
    |     flush and destroy it
    |
    | method operator size takes nothing returns integer
    |     returns the size of the TableArray
    |
    | method operator [] takes integer key returns Table
    |     returns a Table accessible exclusively to index "key"
*/
    
globals
    private integer less = 0    //Index generation for TableArrays (below 0).
    private integer more = 8190 //Index generation for Tables.
    //Configure it if you use more than 8190 "key" variables in your map (this will never happen though).
    
    private hashtable ht = InitHashtable()
    private key sizeK
    private key listK
endglobals
    
private struct dex extends array
    static method operator size takes nothing returns Table
        return sizeK
    endmethod
    static method operator list takes nothing returns Table
        return listK
    endmethod
endstruct
    
private struct handles extends array
    method has takes integer key returns boolean
        return HaveSavedHandle(ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSavedHandle(ht, this, key)
    endmethod
endstruct
    
private struct agents extends array
    method operator []= takes integer key, agent value returns nothing
        call SaveAgentHandle(ht, this, key, value)
    endmethod
endstruct
    
//! textmacro NEW_ARRAY takes SUPER, FUNC, TYPE
private struct $TYPE$s extends array
    method operator [] takes integer key returns $TYPE$
        return Load$FUNC$(ht, this, key)
    endmethod
    method operator []= takes integer key, $TYPE$ value returns nothing
        call Save$FUNC$(ht, this, key, value)
    endmethod
    method has takes integer key returns boolean
        return HaveSaved$SUPER$(ht, this, key)
    endmethod
    method remove takes integer key returns nothing
        call RemoveSaved$SUPER$(ht, this, key)
    endmethod
endstruct
private module $TYPE$m
    method operator $TYPE$ takes nothing returns $TYPE$s
        return this
    endmethod
endmodule
//! endtextmacro
    
//Run these textmacros to include the entire hashtable API as wrappers.
//Don't be intimidated by the number of macros - Vexorian's map optimizer is
//supposed to kill functions which inline (all of these functions inline).
//! runtextmacro NEW_ARRAY("Real", "Real", "real")
//! runtextmacro NEW_ARRAY("Boolean", "Boolean", "boolean")
//! runtextmacro NEW_ARRAY("String", "Str", "string")
//New textmacro to allow table.integer[] syntax for compatibility with textmacros that might desire it.
//! runtextmacro NEW_ARRAY("Integer", "Integer", "integer")
    
//! runtextmacro NEW_ARRAY("Handle", "PlayerHandle", "player")
//! runtextmacro NEW_ARRAY("Handle", "WidgetHandle", "widget")
//! runtextmacro NEW_ARRAY("Handle", "DestructableHandle", "destructable")
//! runtextmacro NEW_ARRAY("Handle", "ItemHandle", "item")
//! runtextmacro NEW_ARRAY("Handle", "UnitHandle", "unit")
//! runtextmacro NEW_ARRAY("Handle", "AbilityHandle", "ability")
//! runtextmacro NEW_ARRAY("Handle", "TimerHandle", "timer")
//! runtextmacro NEW_ARRAY("Handle", "TriggerHandle", "trigger")
//! runtextmacro NEW_ARRAY("Handle", "TriggerConditionHandle", "triggercondition")
//! runtextmacro NEW_ARRAY("Handle", "TriggerActionHandle", "triggeraction")
//! runtextmacro NEW_ARRAY("Handle", "TriggerEventHandle", "event")
//! runtextmacro NEW_ARRAY("Handle", "ForceHandle", "force")
//! runtextmacro NEW_ARRAY("Handle", "GroupHandle", "group")
//! runtextmacro NEW_ARRAY("Handle", "LocationHandle", "location")
//! runtextmacro NEW_ARRAY("Handle", "RectHandle", "rect")
//! runtextmacro NEW_ARRAY("Handle", "BooleanExprHandle", "boolexpr")
//! runtextmacro NEW_ARRAY("Handle", "SoundHandle", "sound")
//! runtextmacro NEW_ARRAY("Handle", "EffectHandle", "effect")
//! runtextmacro NEW_ARRAY("Handle", "UnitPoolHandle", "unitpool")
//! runtextmacro NEW_ARRAY("Handle", "ItemPoolHandle", "itempool")
//! runtextmacro NEW_ARRAY("Handle", "QuestHandle", "quest")
//! runtextmacro NEW_ARRAY("Handle", "QuestItemHandle", "questitem")
//! runtextmacro NEW_ARRAY("Handle", "DefeatConditionHandle", "defeatcondition")
//! runtextmacro NEW_ARRAY("Handle", "TimerDialogHandle", "timerdialog")
//! runtextmacro NEW_ARRAY("Handle", "LeaderboardHandle", "leaderboard")
//! runtextmacro NEW_ARRAY("Handle", "MultiboardHandle", "multiboard")
//! runtextmacro NEW_ARRAY("Handle", "MultiboardItemHandle", "multiboarditem")
//! runtextmacro NEW_ARRAY("Handle", "TrackableHandle", "trackable")
//! runtextmacro NEW_ARRAY("Handle", "DialogHandle", "dialog")
//! runtextmacro NEW_ARRAY("Handle", "ButtonHandle", "button")
//! runtextmacro NEW_ARRAY("Handle", "TextTagHandle", "texttag")
//! runtextmacro NEW_ARRAY("Handle", "LightningHandle", "lightning")
//! runtextmacro NEW_ARRAY("Handle", "ImageHandle", "image")
//! runtextmacro NEW_ARRAY("Handle", "UbersplatHandle", "ubersplat")
//! runtextmacro NEW_ARRAY("Handle", "RegionHandle", "region")
//! runtextmacro NEW_ARRAY("Handle", "FogStateHandle", "fogstate")
//! runtextmacro NEW_ARRAY("Handle", "FogModifierHandle", "fogmodifier")
//! runtextmacro NEW_ARRAY("Handle", "HashtableHandle", "hashtable")
    
struct Table extends array
    
    // Implement modules for intuitive syntax (tb.handle; tb.unit; etc.)
    implement realm
    implement integerm
    implement booleanm
    implement stringm
    implement playerm
    implement widgetm
    implement destructablem
    implement itemm
    implement unitm
    implement abilitym
    implement timerm
    implement triggerm
    implement triggerconditionm
    implement triggeractionm
    implement eventm
    implement forcem
    implement groupm
    implement locationm
    implement rectm
    implement boolexprm
    implement soundm
    implement effectm
    implement unitpoolm
    implement itempoolm
    implement questm
    implement questitemm
    implement defeatconditionm
    implement timerdialogm
    implement leaderboardm
    implement multiboardm
    implement multiboarditemm
    implement trackablem
    implement dialogm
    implement buttonm
    implement texttagm
    implement lightningm
    implement imagem
    implement ubersplatm
    implement regionm
    implement fogstatem
    implement fogmodifierm
    implement hashtablem
    
    method operator handle takes nothing returns handles
        return this
    endmethod
    
    method operator agent takes nothing returns agents
        return this
    endmethod
    
    //set this = tb[GetSpellAbilityId()]
    method operator [] takes integer key returns Table
        return LoadInteger(ht, this, key) //return this.integer[key]
    endmethod
    
    //set tb[389034] = 8192
    method operator []= takes integer key, Table tb returns nothing
        call SaveInteger(ht, this, key, tb) //set this.integer[key] = tb
    endmethod
    
    //set b = tb.has(2493223)
    method has takes integer key returns boolean
        return HaveSavedInteger(ht, this, key) //return this.integer.has(key)
    endmethod
    
    //call tb.remove(294080)
    method remove takes integer key returns nothing
        call RemoveSavedInteger(ht, this, key) //call this.integer.remove(key)
    endmethod
    
    //Remove all data from a Table instance
    method flush takes nothing returns nothing
        call FlushChildHashtable(ht, this)
    endmethod
    
    //local Table tb = Table.create()
    static method create takes nothing returns Table
        local Table this = dex.list[0]
        
        if this == 0 then
            set this = more + 1
            set more = this
        else
            set dex.list[0] = dex.list[this]
            call dex.list.remove(this) //Clear hashed memory
        endif
        
        debug set dex.list[this] = -1
        return this
    endmethod
    
    // Removes all data from a Table instance and recycles its index.
    //
    //     call tb.destroy()
    //
    method destroy takes nothing returns nothing
        debug if dex.list[this] != -1 then
            debug call BJDebugMsg("Table Error: Tried to double-free instance: " + I2S(this))
            debug return
        debug endif
        
        call this.flush()
        
        set dex.list[this] = dex.list[0]
        set dex.list[0] = this
    endmethod
    
    //! runtextmacro optional TABLE_BC_METHODS()
endstruct
    
//! runtextmacro optional TABLE_BC_STRUCTS()
    
struct TableArray extends array
    
    //Returns a new TableArray to do your bidding. Simply use:
    //
    //    local TableArray ta = TableArray[array_size]
    //
    static method operator [] takes integer array_size returns TableArray
        local Table tb = dex.size[array_size] //Get the unique recycle list for this array size
        local TableArray this = tb[0]         //The last-destroyed TableArray that had this array size
        
        debug if array_size <= 0 then
            debug call BJDebugMsg("TypeError: Invalid specified TableArray size: " + I2S(array_size))
            debug return 0
        debug endif
        
        if this == 0 then
            set this = less - array_size
            set less = this
        else
            set tb[0] = tb[this]  //Set the last destroyed to the last-last destroyed
            call tb.remove(this)  //Clear hashed memory
        endif
        
        set dex.size[this] = array_size //This remembers the array size
        return this
    endmethod
    
    //Returns the size of the TableArray
    method operator size takes nothing returns integer
        return dex.size[this]
    endmethod
    
    //This magic method enables two-dimensional[array][syntax] for Tables,
    //similar to the two-dimensional utility provided by hashtables them-
    //selves.
    //
    //ta[integer a].unit[integer b] = unit u
    //ta[integer a][integer c] = integer d
    //
    //Inline-friendly when not running in debug mode
    //
    method operator [] takes integer key returns Table
        static if DEBUG_MODE then
            local integer i = this.size
            if i == 0 then
                call BJDebugMsg("IndexError: Tried to get key from invalid TableArray instance: " + I2S(this))
                return 0
            elseif key < 0 or key >= i then
                call BJDebugMsg("IndexError: Tried to get key [" + I2S(key) + "] from outside TableArray bounds: " + I2S(i))
                return 0
            endif
        endif
        return this + key
    endmethod
    
    //Destroys a TableArray without flushing it; I assume you call .flush()
    //if you want it flushed too. This is a public method so that you don't
    //have to loop through all TableArray indices to flush them if you don't
    //need to (ie. if you were flushing all child-keys as you used them).
    //
    method destroy takes nothing returns nothing
        local Table tb = dex.size[this.size]
        
        debug if this.size == 0 then
            debug call BJDebugMsg("TypeError: Tried to destroy an invalid TableArray: " + I2S(this))
            debug return
        debug endif
        
        if tb == 0 then
            //Create a Table to index recycled instances with their array size
            set tb = Table.create()
            set dex.size[this.size] = tb
        endif
        
        call dex.size.remove(this) //Clear the array size from hash memory
        
        set tb[this] = tb[0]
        set tb[0] = this
    endmethod
    
    private static Table tempTable
    private static integer tempEnd
    
    //Avoids hitting the op limit
    private static method clean takes nothing returns nothing
        local Table tb = .tempTable
        local integer end = tb + 0x1000
        if end < .tempEnd then
            set .tempTable = end
            call ForForce(bj_FORCE_PLAYER[0], function thistype.clean)
        else
            set end = .tempEnd
        endif
        loop
            call tb.flush()
            set tb = tb + 1
            exitwhen tb == end
        endloop
    endmethod
    
    //Flushes the TableArray and also destroys it. Doesn't get any more
    //similar to the FlushParentHashtable native than this.
    //
    method flush takes nothing returns nothing
        debug if this.size == 0 then
            debug call BJDebugMsg("TypeError: Tried to flush an invalid TableArray instance: " + I2S(this))
            debug return
        debug endif
        set .tempTable = this
        set .tempEnd = this + this.size
        call ForForce(bj_FORCE_PLAYER[0], function thistype.clean)
        call this.destroy()
    endmethod
    
endstruct
    
endlibrary//===========================================================================
// Trigger: NxStack
//===========================================================================
library NxStack /* v1.0.0.1
************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage	/*
*
************************************************************************************
*
*	module NxStack
*
*		Description
*		-------------------------
*
*			Collection Properties:
*
*				Unique to Collection
*				Allocated
*				Not 0
*
*		Fields
*		-------------------------
*
*			readonly static integer sentinel
*
*			readonly thistype first
*			readonly thistype next
*
*		Methods
*		-------------------------
*
*			method destroy takes nothing returns nothing
*
*			method push takes nothing returns thistype
*			method pop takes nothing returns nothing
*
*			method clear takes nothing returns nothing
*				-	Initializes stack, use instead of create
*
*			debug static method calculateMemoryUsage takes nothing returns integer
*			debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	module NxStack
		private static thistype nodeCount = 0
		debug private boolean isCollection
		debug private boolean isNode
		
		private thistype _next
		method operator next takes nothing returns thistype
			debug call ThrowError(this == 0,	"NxStack", "next", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"NxStack", "next", "thistype", this, "Attempted To Read Invalid Node.")
			return _next
		endmethod
		
		private thistype _first
		method operator first takes nothing returns thistype
			debug call ThrowError(this == 0,		"NxStack", "first", "thistype", this, "Attempted To Read Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "first", "thistype", this, "Attempted To Read Invalid Stack.")
			return _first
		endmethod
		
		static method operator sentinel takes nothing returns integer
			return 0
		endmethod
		
		private static method allocateNode takes nothing returns thistype
			local thistype this = thistype(0)._next
			
			if (0 == this) then
				debug call ThrowError(nodeCount == 8191, "NxStack", "allocateNode", "thistype", 0, "Overflow.")
				
				set this = nodeCount + 1
				set nodeCount = this
			else
				set thistype(0)._next = _next
			endif
			
			return this
		endmethod
		
		method push takes nothing returns thistype
			local thistype node = allocateNode()
			
			debug call ThrowError(this == 0,		"NxStack", "push", "thistype", this, "Attempted To Push On To Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "push", "thistype", this, "Attempted To Push On To Invalid Stack.")
			
			debug set node.isNode = true
			
			set node._next = _first
			set _first = node
			
			return node
		endmethod
		method pop takes nothing returns nothing
			local thistype node = _first
			
			debug call ThrowError(this == 0,		"NxStack", "pop", "thistype", this, "Attempted To Pop Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "pop", "thistype", this, "Attempted To Pop Invalid Stack.")
			debug call ThrowError(node == 0,		"NxStack", "pop", "thistype", this, "Attempted To Pop Empty Stack.")
			
			debug set node.isNode = false
			
			set _first = node._next
			
			set node._next = thistype(0)._next
			set thistype(0)._next = node
		endmethod
		private method getBottom takes nothing returns thistype
			set this = _first
		
			loop
				exitwhen _next == 0
				set this = _next
			endloop
			
			return this
		endmethod
		method clear takes nothing returns nothing
			debug local thistype node = _first
		
			debug call ThrowError(this == 0, "NxStack", "clear", "thistype", this, "Attempted To Clear Null Stack.")
			
			debug if (not isCollection) then
				debug set isCollection = true
				
				debug set _first = 0
				
				debug return
			debug endif
			
			static if DEBUG_MODE then
				loop
					exitwhen node == 0
					set node.isNode = false
					set node = node._next
				endloop
			endif
			
			if (_first == 0) then
				return
			endif
			
			set getBottom()._next = thistype(0)._next
			set thistype(0)._next = _first
			set _first = 0
		endmethod
		method destroy takes nothing returns nothing
			debug call ThrowError(this == 0,		"NxStack", "destroy", "thistype", this, "Attempted To Destroy Null Stack.")
			debug call ThrowError(not isCollection,	"NxStack", "destroy", "thistype", this, "Attempted To Destroy Invalid Stack.")
			
			call clear()
				
			debug set isCollection = false
		endmethod
		
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				local thistype start = 1
				local thistype end = 8191
				local integer count = 0
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						set count = checkRegion(start, end)
						set start = end + 1
					else
						set count = checkRegion(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return count
			endmethod
			
			private static method checkRegion takes thistype start, thistype end returns integer
				local integer count = 0
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						set count = count + 1
					endif
					if (start.isCollection) then
						set count = count + 1
					endif
					set start = start + 1
				endloop
				
				return count
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				local thistype start = 1
				local thistype end = 8191
				local string memory = null
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						set memory = memory + checkRegion2(start, end)
						set start = end + 1
					else
						set memory = memory + checkRegion2(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return memory
			endmethod
			
			private static method checkRegion2 takes thistype start, thistype end returns string
				local string memory = null
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "N"
						endif
					endif
					if (start.isCollection) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "C"
						endif
					endif
					set start = start + 1
				endloop
				
				return memory
			endmethod
		endif
	endmodule
endlibrary//===========================================================================
// Trigger: NxListT
//===========================================================================
library NxListT /* v1.0.0.1
************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage	/*
*		*/ TableField	/*
*
************************************************************************************
*
*	module NxListT
*
*		Description
*		-------------------------
*
*			NA
*
*		Fields
*		-------------------------
*
*			readonly static integer sentinel
*
*			readonly thistype list
*
*			readonly thistype first
*			readonly thistype last
*
*			readonly thistype next
*		readonly thistype prev
*
*		Methods
*		-------------------------
*
*			method destroy takes nothing returns nothing
*				-	May only destroy lists
*
*			method push takes nothing returns thistype
*			method enqueue takes nothing returns thistype
*
*			method pop takes nothing returns nothing
*			method dequeue takes nothing returns nothing
*
*			method remove takes nothing returns nothing
*
*			method clear takes nothing returns nothing
*				-	Initializes list, use instead of create
*
*			debug static method calculateMemoryUsage takes nothing returns integer
*			debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	private keyword isNode
	private keyword isCollection
	private keyword p_list
	private keyword p_next
	private keyword p_prev
	private keyword p_first
	private keyword p_last
	
	module NxListT
		private static thistype nodeCount = 0
		
		static if DEBUG_MODE then
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "isNode", "boolean")
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "isCollection", "boolean")
		endif
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_list", "thistype")
		method operator list takes nothing returns thistype
			debug call ThrowError(this == 0,	"NxList", "list", "thistype", this, "Attempted To Read Null Node.")
			debug call ThrowError(not isNode,	"NxList", "list", "thistype", this, "Attempted To Read Invalid Node.")
			return p_list
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_next", "thistype")
		method operator next takes nothing returns thistype
			debug call ThrowError(this == 0,	"NxList", "next", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"NxList", "next", "thistype", this, "Attempted To Read Invalid Node.")
			return p_next
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_prev", "thistype")
		method operator prev takes nothing returns thistype
			debug call ThrowError(this == 0,	"NxList", "prev", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"NxList", "prev", "thistype", this, "Attempted To Read Invalid Node.")
			return p_prev
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_first", "thistype") 
		method operator first takes nothing returns thistype
			debug call ThrowError(this == 0,		"NxList", "first", "thistype", this, "Attempted To Read Null List.")
			debug call ThrowError(not isCollection,	"NxList", "first", "thistype", this, "Attempted To Read Invalid List.")
			return p_first
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_last", "thistype")
		method operator last takes nothing returns thistype
			debug call ThrowError(this == 0,		"NxList", "last", "thistype", this, "Attempted To Read Null List.")
			debug call ThrowError(not isCollection,	"NxList", "last", "thistype", this, "Attempted To Read Invalid List.")
			return p_last
		endmethod
		
		static method operator sentinel takes nothing returns integer
			return 0
		endmethod
		
		private static method allocateNode takes nothing returns thistype
			local thistype this = thistype(0).p_next
			
			if (0 == this) then
				set this = nodeCount + 1
				set nodeCount = this
			else
				set thistype(0).p_next = p_next
			endif
			
			return this
		endmethod
		
		method push takes nothing returns thistype
			local thistype node = allocateNode()
			
			debug call ThrowError(this == 0,		"NxList", "push", "thistype", this, "Attempted To Push On To Null List.")
			debug call ThrowError(not isCollection,	"NxList", "push", "thistype", this, "Attempted To Push On To Invalid List.")
			
			debug set node.isNode = true
			
			set node.p_list = this
		
			if (p_first == 0) then
				set p_first = node
				set p_last = node
				set node.p_next = 0
			else
				set p_first.p_prev = node
				set node.p_next = p_first
				set p_first = node
			endif
			
			set node.p_prev = 0
			
			return node
		endmethod
		method enqueue takes nothing returns thistype
			local thistype node = allocateNode()
			
			debug call ThrowError(this == 0,		"NxList", "enqueue", "thistype", this, "Attempted To Enqueue On To Null List.")
			debug call ThrowError(not isCollection,	"NxList", "enqueue", "thistype", this, "Attempted To Enqueue On To Invalid List.")
			
			debug set node.isNode = true
			
			set node.p_list = this
		
			if (p_first == 0) then
				set p_first = node
				set p_last = node
				set node.p_prev = 0
			else
				set p_last.p_next = node
				set node.p_prev = p_last
				set p_last = node
			endif
			
			set node.p_next = 0
			
			return node
		endmethod
		method pop takes nothing returns nothing
			local thistype node = p_first
			
			debug call ThrowError(this == 0,		"NxList", "pop", "thistype", this, "Attempted To Pop Null List.")
			debug call ThrowError(not isCollection,	"NxList", "pop", "thistype", this, "Attempted To Pop Invalid List.")
			debug call ThrowError(node == 0,		"NxList", "pop", "thistype", this, "Attempted To Pop Empty List.")
			
			debug set node.isNode = false
			
			set p_first.p_list = 0
			
			set p_first = p_first.p_next
			if (p_first == 0) then
				set p_last = 0
			else
				set p_first.p_prev = 0
			endif
			
			set node.p_next = thistype(0).p_next
			set thistype(0).p_next = node
		endmethod
		method dequeue takes nothing returns nothing
			local thistype node = p_last
			
			debug call ThrowError(this == 0,		"NxList", "dequeue", "thistype", this, "Attempted To Dequeue Null List.")
			debug call ThrowError(not isCollection,	"NxList", "dequeue", "thistype", this, "Attempted To Dequeue Invalid List.")
			debug call ThrowError(node == 0,		"NxList", "dequeue", "thistype", this, "Attempted To Dequeue Empty List.")
			
			debug set node.isNode = false
			
			set p_last.p_list = 0
		
			set p_last = p_last.p_prev
			if (p_last == 0) then
				set p_first = 0
			else
				set p_last.p_next = 0
			endif
			
			set node.p_next = thistype(0).p_next
			set thistype(0).p_next = node
		endmethod
		method remove takes nothing returns nothing
			local thistype node = this
			set this = node.p_list
			
			debug call ThrowError(node == 0,		"NxList", "remove", "thistype", this, "Attempted To Remove Null Node.")
			debug call ThrowError(not node.isNode,	"NxList", "remove", "thistype", this, "Attempted To Remove Invalid Node (" + I2S(node) + ").")
			
			debug set node.isNode = false
			
			set node.p_list = 0
		
			if (0 == node.p_prev) then
				set p_first = node.p_next
			else
				set node.p_prev.p_next = node.p_next
			endif
			if (0 == node.p_next) then
				set p_last = node.p_prev
			else
				set node.p_next.p_prev = node.p_prev
			endif
			
			set node.p_next = thistype(0).p_next
			set thistype(0).p_next = node
		endmethod
		method clear takes nothing returns nothing
			debug local thistype node = p_first
		
			debug call ThrowError(this == 0,		"NxList", "clear", "thistype", this, "Attempted To Clear Null List.")
			
			debug if (not isCollection) then
				debug set isCollection = true
				
				debug set p_first = 0
				debug set p_last = 0
				
				debug return
			debug endif
			
			static if DEBUG_MODE then
				loop
					exitwhen node == 0
					set node.isNode = false
					set node = node.p_next
				endloop
			endif
			
			if (p_first == 0) then
				return
			endif
			
			set p_last.p_next = thistype(0).p_next
			set thistype(0).p_next = p_first
			
			set p_first = 0
			set p_last = 0
		endmethod
		method destroy takes nothing returns nothing
			debug call ThrowError(this == 0,		"NxList", "destroy", "thistype", this, "Attempted To Destroy Null List.")
			debug call ThrowError(not isCollection,	"NxList", "destroy", "thistype", this, "Attempted To Destroy Invalid List.")
			
			call clear()
			
			debug set isCollection = false
		endmethod
		
		private static method onInit takes nothing returns nothing
			static if DEBUG_MODE then
				//! runtextmacro INITIALIZE_TABLE_FIELD("isNode")
				//! runtextmacro INITIALIZE_TABLE_FIELD("isCollection")
			endif
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_list")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_next")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_prev")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_first")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_last")
		endmethod
		
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				local thistype start = 1
				local thistype end = 8191
				local integer count = 0
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						return count + checkRegion(start, end)
					else
						set count = count + checkRegion(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return count
			endmethod
			
			private static method checkRegion takes thistype start, thistype end returns integer
				local integer count = 0
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						set count = count + 1
					endif
					if (start.isCollection) then
						set count = count + 1
					endif
					set start = start + 1
				endloop
				
				return count
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				local thistype start = 1
				local thistype end = 8191
				local string memory = null
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						set memory = memory + checkRegion2(start, end)
						set start = end + 1
					else
						set memory = memory + checkRegion2(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return memory
			endmethod
			
			private static method checkRegion2 takes thistype start, thistype end returns string
				local string memory = null
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "N"
						endif
					endif
					if (start.isCollection) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "C"
						endif
					endif
					set start = start + 1
				endloop
				
				return memory
			endmethod
		endif
	endmodule
endlibrary//===========================================================================
// Trigger: UniqueNxListT
//===========================================================================
library UniqueNxListT /* v1.0.0.1
************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage /*
*		*/ TableField	/*
*
************************************************************************************
*
*	module UniqueNxListT
*
*		Description
*		-------------------------
*
*			Node Properties:
*
*				Unique
*				Allocated
*				Not 0
*
*		Fields
*		-------------------------
*
*			readonly static integer sentinel
*
*			readonly thistype list
*
*			readonly thistype first
*			readonly thistype last
*
*			readonly thistype next
*			readonly thistype prev
*
*		Methods
*		-------------------------
*
*			method destroy takes nothing returns nothing
*				-	May only destroy lists
*
*			method push takes thistype node returns nothing
*			method enqueue takes thistype node returns nothing
*
*			method pop takes nothing returns nothing
*			method dequeue takes nothing returns nothing
*
*			method remove takes nothing returns nothing
*
*			method clear takes nothing returns nothing
*				-	Initializes list, use instead of create
*
*			debug static method calculateMemoryUsage takes nothing returns integer
*			debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	private keyword isNode
	private keyword isCollection
	private keyword p_list
	private keyword p_next
	private keyword p_prev
	private keyword p_first
	private keyword p_last

	module UniqueNxListT
		static if DEBUG_MODE then
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "isNode", "boolean")
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "isCollection", "boolean")
		endif
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_list", "thistype")
		method operator list takes nothing returns thistype
			debug call ThrowError(this == 0,	"UniqueNxListT", "list", "thistype", this, "Attempted To Read Null Node.")
			debug call ThrowError(not isNode,	"UniqueNxListT", "list", "thistype", this, "Attempted To Read Invalid Node.")
			return p_list
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_next", "thistype")
		method operator next takes nothing returns thistype
			debug call ThrowError(this == 0,	"UniqueNxListT", "next", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"UniqueNxListT", "next", "thistype", this, "Attempted To Read Invalid Node.")
			return p_next
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_prev", "thistype")
		method operator prev takes nothing returns thistype
			debug call ThrowError(this == 0,	"UniqueNxListT", "prev", "thistype", this, "Attempted To Go Out Of Bounds.")
			debug call ThrowError(not isNode,	"UniqueNxListT", "prev", "thistype", this, "Attempted To Read Invalid Node.")
			return p_prev
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_first", "thistype")
		method operator first takes nothing returns thistype
			debug call ThrowError(this == 0,		"UniqueNxListT", "first", "thistype", this, "Attempted To Read Null List.")
			debug call ThrowError(not isCollection,	"UniqueNxListT", "first", "thistype", this, "Attempted To Read Invalid List.")
			return p_first
		endmethod
		
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "p_last", "thistype")
		method operator last takes nothing returns thistype
			debug call ThrowError(this == 0,		"UniqueNxListT", "last", "thistype", this, "Attempted To Read Null List.")
			debug call ThrowError(not isCollection,	"UniqueNxListT", "last", "thistype", this, "Attempted To Read Invalid List.")
			return p_last
		endmethod
		
		static method operator sentinel takes nothing returns integer
			return 0
		endmethod
		
		method push takes thistype node returns nothing
			debug call ThrowError(this == 0,		"UniqueNxListT", "push", "thistype", this, "Attempted To Push (" + I2S(node) + ") On To Null List.")
			debug call ThrowError(not isCollection,	"UniqueNxListT", "push", "thistype", this, "Attempted To Push (" + I2S(node) + ") On To Invalid List.")
			debug call ThrowError(node == 0,		"UniqueNxListT", "push", "thistype", this, "Attempted To Push Null Node.")
			debug call ThrowError(node.isNode,		"UniqueNxListT", "push", "thistype", this, "Attempted To Push Owned Node (" + I2S(node) + ").")
			
			debug set node.isNode = true
			
			set node.p_list = this
		
			if (p_first == 0) then
				set p_first = node
				set p_last = node
				set node.p_next = 0
			else
				set p_first.p_prev = node
				set node.p_next = p_first
				set p_first = node
			endif
			
			set node.p_prev = 0
		endmethod
		method enqueue takes thistype node returns nothing
			debug call ThrowError(this == 0,		"UniqueNxListT", "enqueue", "thistype", this, "Attempted To Enqueue (" + I2S(node) + ") On To Null List.")
			debug call ThrowError(not isCollection,	"UniqueNxListT", "enqueue", "thistype", this, "Attempted To Enqueue (" + I2S(node) + ") On To Invalid List.")
			debug call ThrowError(node == 0,		"UniqueNxListT", "enqueue", "thistype", this, "Attempted To Enqueue Null Node.")
			debug call ThrowError(node.isNode,		"UniqueNxListT", "enqueue", "thistype", this, "Attempted To Enqueue Owned Node (" + I2S(node) + ").")
			
			debug set node.isNode = true
			
			set node.p_list = this
		
			if (p_first == 0) then
				set p_first = node
				set p_last = node
				set node.p_prev = 0
			else
				set p_last.p_next = node
				set node.p_prev = p_last
				set p_last = node
			endif
			
			set node.p_next = 0
		endmethod
		method pop takes nothing returns nothing
			debug call ThrowError(this == 0,		"UniqueNxListT", "pop", "thistype", this, "Attempted To Pop Null List.")
			debug call ThrowError(not isCollection,	"UniqueNxListT", "pop", "thistype", this, "Attempted To Pop Invalid List.")
			debug call ThrowError(p_first == 0,		"UniqueNxListT", "pop", "thistype", this, "Attempted To Pop Empty List.")
			
			debug set p_first.isNode = false
			
			set p_first.p_list = 0
			
			set p_first = p_first.p_next
			if (p_first == 0) then
				set p_last = 0
			else
				set p_first.p_prev = 0
			endif
		endmethod
		method dequeue takes nothing returns nothing
			debug call ThrowError(this == 0,		"UniqueNxListT", "dequeue", "thistype", this, "Attempted To Dequeue Null List.")
			debug call ThrowError(not isCollection,	"UniqueNxListT", "dequeue", "thistype", this, "Attempted To Dequeue Invalid List.")
			debug call ThrowError(p_last == 0,		"UniqueNxListT", "dequeue", "thistype", this, "Attempted To Dequeue Empty List.")
			
			debug set p_last.isNode = false
			
			set p_last.p_list = 0
		
			set p_last = p_last.p_prev
			if (p_last == 0) then
				set p_first = 0
			else
				set p_last.p_next = 0
			endif
		endmethod
		method remove takes nothing returns nothing
			local thistype node = this
			set this = node.p_list
			
			debug call ThrowError(node == 0,		"UniqueNxListT", "remove", "thistype", this, "Attempted To Remove Null Node.")
			debug call ThrowError(not node.isNode,	"UniqueNxListT", "remove", "thistype", this, "Attempted To Remove Invalid Node (" + I2S(node) + ").")
			
			debug set node.isNode = false
			
			set node.p_list = 0
		
			if (0 == node.p_prev) then
				set p_first = node.p_next
			else
				set node.p_prev.p_next = node.p_next
			endif
			if (0 == node.p_next) then
				set p_last = node.p_prev
			else
				set node.p_next.p_prev = node.p_prev
			endif
		endmethod
		method clear takes nothing returns nothing
			debug local thistype node = p_first
		
			debug call ThrowError(this == 0,		"UniqueNxListT", "clear", "thistype", this, "Attempted To Clear Null List.")
			
			debug if (not isCollection) then
				debug set isCollection = true
				
				debug set p_first = 0
				debug set p_last = 0
				
				debug return
			debug endif
			
			static if DEBUG_MODE then
				loop
					exitwhen node == 0
					set node.isNode = false
					set node = node.p_next
				endloop
			endif
			
			if (p_first == 0) then
				return
			endif
			
			set p_first = 0
			set p_last = 0
		endmethod
		method destroy takes nothing returns nothing
			debug call ThrowError(this == 0,		"UniqueNxListT", "destroy", "thistype", this, "Attempted To Destroy Null List.")
			debug call ThrowError(not isCollection,	"UniqueNxListT", "destroy", "thistype", this, "Attempted To Destroy Invalid List.")
			
			call clear()
			
			debug set isCollection = false
		endmethod
		
		private static method onInit takes nothing returns nothing
			static if DEBUG_MODE then
				//! runtextmacro INITIALIZE_TABLE_FIELD("isNode")
				//! runtextmacro INITIALIZE_TABLE_FIELD("isCollection")
			endif
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_list")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_next")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_prev")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_first")
			//! runtextmacro INITIALIZE_TABLE_FIELD("p_last")
		endmethod
		
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				local thistype start = 1
				local thistype end = 8191
				local integer count = 0
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						return count + checkRegion(start, end)
					else
						set count = count + checkRegion(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return count
			endmethod
			
			private static method checkRegion takes thistype start, thistype end returns integer
				local integer count = 0
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						set count = count + 1
					endif
					if (start.isCollection) then
						set count = count + 1
					endif
					set start = start + 1
				endloop
				
				return count
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				local thistype start = 1
				local thistype end = 8191
				local string memory = null
				
				loop
					exitwhen integer(start) > integer(end)
					if (integer(start) + 500 > integer(end)) then
						set memory = memory + checkRegion2(start, end)
						set start = end + 1
					else
						set memory = memory + checkRegion2(start, start + 500)
						set start = start + 501
					endif
				endloop
				
				return memory
			endmethod
			
			private static method checkRegion2 takes thistype start, thistype end returns string
				local string memory = null
			
				loop
					exitwhen integer(start) > integer(end)
					if (start.isNode) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "N"
						endif
					endif
					if (start.isCollection) then
						if (memory == null) then
							set memory = I2S(start)
						else
							set memory = memory + ", " + I2S(start) + "C"
						endif
					endif
					set start = start + 1
				endloop
				
				return memory
			endmethod
		endif
	endmodule
endlibrary//===========================================================================
// Trigger: WorldBounds
//===========================================================================
library WorldBounds /* v2.0.0.0
************************************************************************************
*
*	struct WorldBounds extends array
*
*		Fields
*		-------------------------
*
*			readonly static integer maxX
*			readonly static integer maxY
*			readonly static integer minX
*			readonly static integer minY
*
*			readonly static integer centerX
*			readonly static integer centerY
*
*			readonly static rect world
*			readonly static region worldRegion
*
************************************************************************************/
	private module WorldBoundInit
		private static method onInit takes nothing returns nothing
			set world=GetWorldBounds()
			
			set maxX = R2I(GetRectMaxX(world))
			set maxY = R2I(GetRectMaxY(world))
			set minX = R2I(GetRectMinX(world))
			set minY = R2I(GetRectMinY(world))
			
			set centerX = R2I((maxX + minX)/2)
			set centerY = R2I((minY + maxY)/2)
			
			set worldRegion = CreateRegion()
			
			call RegionAddRect(worldRegion, world)
		endmethod
	endmodule
	
	struct WorldBounds extends array
		readonly static integer maxX
		readonly static integer maxY
		readonly static integer minX
		readonly static integer minY
		
		readonly static integer centerX
		readonly static integer centerY
		
		readonly static rect world
		
		readonly static region worldRegion
		
		implement WorldBoundInit
	endstruct
endlibrary//===========================================================================
// Trigger: ErrorMessage
//===========================================================================
library ErrorMessage /* v1.0.1.4
*************************************************************************************
*
*	Issue Compliant Error Messages
*
************************************************************************************
*
*	debug function ThrowError takes boolean expression, string libraryName, string functionName, string objectName, integer objectInstance, string description returns nothing
*		-	In the event of an error the game will be permanently paused
*
*	debug function ThrowWarning takes boolean expression, string libraryName, string functionName, string objectName, integer objectInstance, string description returns nothing
*
************************************************************************************/
	static if DEBUG_MODE then
		private struct Fields extends array
			static constant string COLOR_RED = "|cffff0000"
			static constant string COLOR_YELLOW = "|cffffff00"
			static string lastError = null
		endstruct
		
		private function Pause takes nothing returns nothing
			call PauseGame(true)
		endfunction
		
		private function ThrowMessage takes string libraryName, string functionName, string objectName, integer objectInstance, string description, string errorType, string color returns nothing
			local string str
			
			local string color_braces = "|cff66FF99"
			local string orange = "|cffff6600"
			
			set str = "->\n-> " + color_braces + "{|r " + "Library" + color_braces + "(" + orange + libraryName + color_braces + ")"
			if (objectName != null) then
				if (objectInstance > 0) then
					set str = str + "|r.Object" + color_braces + "(" + orange + objectName + color_braces + " (|rinstance = " + orange + I2S(objectInstance) + color_braces + ") )" + "|r." + "Method" + color_braces + "(" + orange + functionName + color_braces + ")"
				else
					set str = str + "|r.Object" + color_braces + "(" + orange + objectName + color_braces + ")|r." + "Method" + color_braces + "(" + orange + functionName + color_braces + ")"
				endif
			else
				set str = str + "|r." + "Function" + color_braces + "(" + orange + functionName + color_braces + ")"
			endif
			
			set str = str + color_braces + " }|r " + "has thrown an exception of type " + color_braces + "(" + color + errorType + color_braces + ")|r."
			
			set Fields.lastError = str + "\n->\n" + "->	" + color + description + "|r\n->"
		endfunction
		
		function ThrowError takes boolean expression, string libraryName, string functionName, string objectName, integer objectInstance, string description returns nothing
			if (Fields.lastError != null) then
				set objectInstance = 1/0
			endif
		
			if (expression) then
				call ThrowMessage(libraryName, functionName, objectName, objectInstance, description, "Error", Fields.COLOR_RED)
				call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,60000,Fields.lastError)
				call TimerStart(CreateTimer(), 0, true, function Pause)
				set objectInstance = 1/0
			endif
		endfunction

		function ThrowWarning takes boolean expression, string libraryName, string functionName, string objectName, integer objectInstance, string description returns nothing
			if (Fields.lastError != null) then
				set objectInstance = 1/0
			endif
		
			if (expression) then
				call ThrowMessage(libraryName, functionName, objectName, objectInstance, description, "Warning", Fields.COLOR_YELLOW)
				call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,60000,Fields.lastError)
				set Fields.lastError = null
			endif
		endfunction
	endif
endlibrary//===========================================================================
// Trigger: Init
//===========================================================================
library Init /* v1.0.0.0
************************************************************************************
*
*	module Init
*
*		interface private static method init takes nothing returns nothing
*			-	Runs at map init
*
*************************************************************************************
*
*	module InitTimer
*
*		interface private static method init takes nothing returns nothing
*			-	Runs after a one-shot timer with a period of 0
*
************************************************************************************/
	module Init
		static if thistype.init.exists then
			private static method onInit takes nothing returns nothing
				call init()
			endmethod
		endif
	endmodule
	
	module InitTimer
		static if thistype.init.exists then
			private static method initex takes nothing returns nothing
				call DestroyTimer(GetExpiredTimer())
				call init()
			endmethod
			private static method onInit takes nothing returns nothing
				call TimerStart(CreateTimer(), 0, false, function thistype.initex)
			endmethod
		endif
	endmodule
endlibrary//===========================================================================
// Trigger: TableField
//===========================================================================
library TableField /* v1.0.0.1
************************************************************************************
*
*	*/ uses /*
*
*		*/ Table	/*
*		*/ Init		/*
*
************************************************************************************
*
*	//! textmacro CREATE_TABLE_FIELD takes ACCESS_MODIFIER, TYPE, NAME, RETURN_TYPE
*		-	creates a table field surrounded by method operators
*
*	//! textmacro INITIALIZE_TABLE_FIELD takes NAME
*		-	initializes table field
*		-	used in onInit
*
*	//! textmacro CREATE_TABLE_FIELD_ARRAY takes TYPE, NAME, RETURN_TYPE
*		-	creates a struct that acts as an array
*		-	not used in a struct
*
*	//! textmacro USE_TABLE_FIELD_ARRAY takes ACCESS_MODIFIER, NAME
*		-	creates a field of a struct array
*		-	used in a struct
*
************************************************************************************/
	//! textmacro CREATE_TABLE_FIELD takes ACCESS_MODIFIER, TYPE, NAME, RETURN_TYPE
		private static Table t$NAME$
			
		$ACCESS_MODIFIER$ method operator $NAME$ takes nothing returns $RETURN_TYPE$
			return t$NAME$.$TYPE$[this]
		endmethod
		$ACCESS_MODIFIER$ method operator $NAME$= takes $RETURN_TYPE$ value returns nothing
			set t$NAME$.$TYPE$[this] = value
		endmethod
		$ACCESS_MODIFIER$ method $NAME$_clear takes nothing returns nothing
			call t$NAME$.$TYPE$.remove(this)
		endmethod
	//! endtextmacro
	
	//! textmacro CREATE_TABLE_FIELD_ARRAY takes TYPE, NAME, RETURN_TYPE
		private struct T$NAME$ extends array
			private static Table table
			
			method operator [] takes integer index returns $RETURN_TYPE$
				return table.$TYPE$[index]
			endmethod
			method operator []= takes integer index, $RETURN_TYPE$ value returns nothing
				set table.$TYPE$[index] = value
			endmethod
			static method remove takes integer index returns nothing
				call table.$TYPE$.remove(index)
			endmethod
			static method clear takes nothing returns nothing
				call table.flush()
			endmethod
			
			private static method init takes nothing returns nothing
				set table = Table.create()
			endmethod
			
			implement Init
		endstruct
	//! endtextmacro
	
	//! textmacro USE_TABLE_FIELD_ARRAY takes ACCESS_MODIFIER, NAME
		$ACCESS_MODIFIER$ static T$NAME$ $NAME$ = 0
	//! endtextmacro
	
	//! textmacro INITIALIZE_TABLE_FIELD takes NAME
		set t$NAME$ = Table.create()
	//! endtextmacro
endlibrary//===========================================================================
// Trigger: Trigger Refresh
//===========================================================================
library TriggerRefresh /* v1.0.3.0
*************************************************************************************
*
*   Optimal trigger refreshing for unit events. Used in such things as Damage Detection
*   Systems.
*
*   Events are never destroyed. When a unit event is registered to a trigger and that
*   unit no longer exists, the event remains. The trigger has to be recreated in order
*   to clean the leak. This resource recreates triggers in the most optimal manner possible.
*
*   Used in DamageEvent and recommended for all Damage Detection Systems.
*
*   Place the macros in order at the bottom of the DDS Library.
*
*************************************************************************************
*
*   */uses/*
*
*       */ UnitIndexer      /*      hiveworkshop.com/forums/jass-functions-413/unit-indexer-172090/
*       All Requirements of Unit Indexer are not needed as they are included with RefreshTrigger Refresh
*
*************************************************************************************
*
*   //! textmacro TRIGGER_REFRESH takes TRIGGER_SIZE, TRIGGER_EVENT, CODE
*
*       This macro creates the refreshing trigger. 
*
*           TRIGGER_SIZE
*               How many units to register to a given trigger. More units = less refreshes, but
*               more fps spikes. A value of 80 is recommended.
*
*           TRIGGER_EVENT
*               The event to register to the trigger. Example: EVENT_UNIT_DAMAGED.
*
*           CODE
*               Registers code to the trigger. Only 1 function may be registered to the trigger.
*
*   private keyword RefreshTrigger
*   RefreshTrigger(UnitIndex).parent.trigger
*       -   enable/disable trigger for specific unit
*
*************************************************************************************
*
*   //quick and dirty DDS
*   library MyDDS
*       private function Core takes nothing returns nothing
*           //will display whenever a unit is damaged
*           call DisplayTimedTextToPlayer(GetLocalPlayer(),0,0,10,R2S(GetEventDamage()))
*       endfunction
*
*       //! runtextmacro TRIGGER_REFRESH("80", "EVENT_UNIT_DAMAGED", "function Core")
*   endlibrary
*
*************************************************************************************/
endlibrary

//! textmacro TRIGGER_REFRESH takes TRIGGER_SIZE, TRIGGER_EVENT, CODE
    scope TriggerRefresh
        globals
            private boolexpr condition
        endglobals
        
        struct RefreshTrigger extends array
            private static integer instanceCount = 0
        
            private thistype first
            private thistype next
            private thistype prev
            readonly thistype parent
            
            private integer inactiveUnits
            readonly integer activeUnits
            
            readonly trigger trigger
            
            private method registerUnit takes UnitIndex whichUnit returns boolean
                if (activeUnits < $TRIGGER_SIZE$) then
                    call TriggerRegisterUnitEvent(trigger, whichUnit.unit, $TRIGGER_EVENT$)
                    set activeUnits = activeUnits + 1
                    
                    return true
                endif
                
                return false
            endmethod
            private method unregisterUnit takes nothing returns nothing
                set inactiveUnits = inactiveUnits + 1
                set activeUnits = activeUnits - 1
            endmethod
            
            private method createTrigger takes nothing returns nothing
                set trigger = CreateTrigger()
                call TriggerAddCondition(trigger, condition)
            endmethod
            private method remakeTrigger takes nothing returns nothing
                call DestroyTrigger(trigger)
                call createTrigger()
            endmethod
            private method rebuildTrigger takes nothing returns nothing
                local thistype current = first
                
                call remakeTrigger()
                
                /*
                *   Iterate over all units registered to the trigger and reregister them
                */
                set current.prev.next = 0
                loop
                    exitwhen 0 == current
                    call TriggerRegisterUnitEvent(trigger, UnitIndex(current).unit, $TRIGGER_EVENT$)
                    set current = current.next
                endloop
                set first.prev.next = current
            endmethod
            
            private method remake takes nothing returns nothing
                if (inactiveUnits == $TRIGGER_SIZE$) then
                    set inactiveUnits = 0
                    call rebuildTrigger()
                endif
            endmethod
            
            private method addToList takes thistype whichUnit returns nothing
                set whichUnit.parent = this
            
                if (0 == first) then
                    set first = whichUnit
                    set whichUnit.next = whichUnit
                    set whichUnit.prev = whichUnit
                else
                    set this = first
                    
                    set whichUnit.prev = prev
                    set whichUnit.next = this
                    set prev.next = whichUnit
                    set prev = whichUnit
                endif
            endmethod
            method add takes thistype whichUnit returns boolean
                if (0 == this) then
                    return false
                endif
            
                if (registerUnit(whichUnit)) then
                    call addToList(whichUnit)
                    
                    return true
                endif
                
                return false
            endmethod
            
            private method removeFromList takes thistype whichUnit returns nothing
                set whichUnit.parent = 0
            
                set whichUnit.prev.next = whichUnit.next
                set whichUnit.next.prev = whichUnit.prev
                
                if (first == whichUnit) then
                    set first = whichUnit.next
                    if (first == whichUnit) then
                        set first = 0
                    endif
                endif
            endmethod
            static method remove takes thistype whichUnit returns nothing
                local thistype this = whichUnit.parent
            
                call removeFromList(whichUnit)
                call unregisterUnit()
                call remake()
            endmethod
            
            private static method allocate takes nothing returns thistype
                set instanceCount = instanceCount + 1
                return instanceCount
            endmethod
            static method create takes nothing returns thistype
                local thistype this = allocate()
                
                call createTrigger()
                
                return this
            endmethod
        endstruct
        
        private struct TriggerHeapInner extends array
            readonly static integer size = 0
            readonly thistype node
            readonly thistype heap
            
            public method bubbleUp takes nothing returns nothing
                local integer activeUnits = RefreshTrigger(this).activeUnits
                local thistype heapPosition = heap
                
                local thistype parent
                
                /*
                *   Bubble node up
                */
                loop
                    set parent = heapPosition/2
                    
                    if (integer(parent) != 0 and activeUnits < RefreshTrigger(parent.node).activeUnits) then
                        set heapPosition.node = parent.node
                        set heapPosition.node.heap = heapPosition
                    else
                        exitwhen true
                    endif
                    
                    set heapPosition = parent
                endloop
                
                /*
                *   Update pointers
                */
                set heapPosition.node = this
                set heap = heapPosition
            endmethod
            public method bubbleDown takes nothing returns nothing
                local integer activeUnits = RefreshTrigger(this).activeUnits
                local thistype heapPosition = heap
                
                local thistype left
                local thistype right
                
                /*
                *   Bubble node down
                */
                loop
                    set left = heapPosition*2
                    set right = left + 1
                    
                    if (RefreshTrigger(left.node).activeUnits < activeUnits and RefreshTrigger(left.node).activeUnits < RefreshTrigger(right.node).activeUnits) then
                        /*
                        *   Go left
                        */
                        set heapPosition.node = left.node
                        set heapPosition.node.heap = heapPosition
                        set heapPosition = left
                    elseif (RefreshTrigger(right.node).activeUnits < activeUnits) then
                        /*
                        *   Go right
                        */
                        set heapPosition.node = right.node
                        set heapPosition.node.heap = heapPosition
                        set heapPosition = right
                    else
                        exitwhen true
                    endif
                endloop
                
                /*
                *   Update pointers
                */
                set heapPosition.node = this
                set heap = heapPosition
            endmethod
            
            static method insert takes thistype this returns nothing
                /*
                *   Increase heap size
                */
                set size = size + 1
                
                /*
                *   Store node in last heap position
                */
                set thistype(size).node = this
                set heap = size
                
                /*
                *   Bubble node into correct position
                */
                call bubbleUp()
            endmethod
        endstruct
        
        private struct TriggerHeap extends array
            static method add takes UnitIndex whichUnit returns nothing
                local RefreshTrigger trig = TriggerHeapInner(1).node
                
                if (not trig.add(whichUnit)) then
                    set trig = RefreshTrigger.create()
                    call trig .add(whichUnit)
                    call TriggerHeapInner.insert(trig)
                else
                    call TriggerHeapInner(trig).bubbleDown()
                endif
            endmethod
            static method remove takes UnitIndex whichUnit returns nothing
                local RefreshTrigger trig = RefreshTrigger(whichUnit).parent
                call RefreshTrigger.remove(whichUnit)
                call TriggerHeapInner(trig).bubbleUp()
            endmethod
        endstruct
        
        private module TriggerRefreshInitModule
            private static method onInit takes nothing returns nothing
                call init($CODE$)
            endmethod
        endmodule
        
        private struct TriggerRefreshInit extends array
            private static method onIndex takes nothing returns boolean
                call TriggerHeap.add(UnitIndexer.eventIndex)
                
                return false
            endmethod
            
            private static method onDeindex takes nothing returns boolean
                call TriggerHeap.remove(UnitIndexer.eventIndex)
            
                return false
            endmethod
        
            private static method init takes code c returns nothing
                set condition = Condition(c)
                
				call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onIndex))
				call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onDeindex))
            endmethod
            
            implement TriggerRefreshInitModule
        endstruct
    endscope
//! endtextmacro//===========================================================================
// Trigger: BooleanExpression
//===========================================================================
library BooleanExpression /* v1.1.0.0
************************************************************************************
*
*	*/ uses /*
*
*		*/ ErrorMessage	/*
*		*/ ListT		/*
*		*/ NxStackT		/*
*		*/ AllocT		/*
*		*/ Table		/*
*		*/ Init			/*
*		*/ TableField	/*
*
************************************************************************************
*
*	struct BooleanExpression extends array
*
*		Description
*		-------------------------
*
*			Creates a single boolean expression via Or's
*
*			Provides a slight speed boost
*
*			Allows the for the safe usage of TriggerRemoveCondition given that the only boolexpr on the trigger
*			is the one from this struct
*
*			To put multiple boolean expressions on to one trigger, combine them with Or. Be sure to destroy later.
*
*			Alternatively, they can be wrapped with another BooleanExpression, but this will add overhead. Only use
*			if more than three are planned to be on one trigger.
*
*		Fields
*		-------------------------
*
*			readonly boolexpr expression
*
*				-	rebuilds expression if expression was modified
*				-	will break triggers unless the expression is removed/added again
*
*				Examples:	call booleanExpression.register(myCode)
*							call TriggerRemoveCondition(thisTrigger, theOneCondition)
*							set theOneCondition = TriggerAddCondition(thisTrigger, booleanExpression.expression)
*
*		Methods
*		-------------------------
*
*			static method create takes boolean reversed returns BooleanExpression
*				-	when reverse is true, the entire expression is run in reverse
*
*			method destroy takes nothing returns nothing
* 
*			method register takes boolexpr expression returns BooleanExpression
*			method unregister takes nothing returns nothing
*
*			method replace takes boolexpr expression returns nothing
*				-	replaces the boolexpr inside of the registered expression
*				-	useful for updating expressions without breaking order
*
*			method clear takes nothing returns nothing
*
*			debug static method calculateMemoryUsage takes nothing returns integer
*			debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************/
	globals
		private constant boolean DEBUG_LOG = false
	endglobals
	
	static if DEBUG_LOG then
		private function print takes string m returns nothing
			call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 60000, m)
		endfunction
	endif
	
	private keyword ListExpression
	private keyword NodeExpression
	
	scope NodeExpressionScope
		private struct Node extends array
			static if DEBUG_LOG then
				private static integer idCount = 0
				private integer id
			endif
		
			/*
			*	Tree Fields
			*/
			//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "root", "thistype")
			//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "left", "thistype")
			//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "right", "thistype")
			
			/*
			*	List Fields
			*/
			//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "next", "thistype")
			//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "prev", "thistype")
			
			/*
			*	Standard Fields
			*/
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolexpr", "expression", "boolexpr")
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "canDestroy", "boolean")
			
			//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "reversed", "boolean")
			//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "list", "ListExpression")
			
			/*
			*	static method allocate takes nothing returns thistype
			*	method deallocate takes nothing returns nothing
			*/
			implement AllocT
			
			static method create takes ListExpression list, boolean reversed returns thistype
				local thistype this = allocate()
				
				set this.reversed = reversed
				set this.list = list
			
				static if DEBUG_LOG then
					set idCount = idCount + 1
					set id = idCount
				endif
				
				return this
			endmethod
			
			/*
			*	Destroy all nodes within tree, clears, only used for complete tree destruction
			*/
			method destroySub takes nothing returns nothing
				/*
				*	Destroy/Clear List Node
				*/
				if (left == 0) then
					set root = 0
					set next = 0
					set prev = 0
				/*
				*	Destroy/Clear Tree Node
				*/
				else
					if (canDestroy) then
						set canDestroy = false
						call DestroyBoolExpr(expression)
					endif
				
					set left.root = 0
					call left.destroySub()
					set left = 0
					
					set right.root = 0
					call right.destroySub()
					set right = 0
				endif
				
				call expression_clear()
				
				call deallocate()
			endmethod
			
			/*
			*	Joins two trees under a new root
			*	Returns new root
			*/
			static method join takes Node left, Node right returns Node
				local Node this = Node.create(left.list, left.reversed)
				
				set this.left = left
				set this.right = right
				set left.root = this
				set right.root = this
				
				if (right.expression == null) then
					if (left.expression == null) then
						call expression_clear()
					else
						set expression = left.expression
					endif
				elseif (left.expression == null) then
					set expression = right.expression
				else
					set canDestroy = true
					set expression = Or(left.expression, right.expression)
				endif
				
				return this
			endmethod
			
			static method joinReverse takes Node left, Node right returns Node
				local Node this = Node.create(left.list, left.reversed)
				
				static if DEBUG_LOG then
					call print("joinReverse: (" + I2S(left.id) + ")R(" + I2S(right.id) + ")")
				endif
				
				set this.left = left
				set this.right = right
				set left.root = this
				set right.root = this
				
				if (right.expression == null) then
					if (left.expression == null) then
						call expression_clear()
					else
						set expression = left.expression
					endif
				elseif (left.expression == null) then
					set expression = right.expression
				else
					set canDestroy = true
					set expression = Or(right.expression, left.expression)
				endif
				
				static if DEBUG_LOG then
					call print("joinReverse Result: (" + this.toString())
				endif
				
				return this
			endmethod
			
			/*
			*	Joins the list nodes of
			*
			*		Tree/Node
			*		Node/Node
			*/
			static method listJoin takes Node tree, Node node returns nothing
				debug call ThrowError(tree == 0, "BooleanExpression.NodeExpressionScope", "listJoin", "Node", 0, "Attempted To Join With Null Tree " + "(" + I2S(tree) + ").")
				debug call ThrowError(node == 0, "BooleanExpression.NodeExpressionScope", "listJoin", "Node", 0, "Attempted To Join With Null Node " + "(" + I2S(node) + ").")
				
				loop
					exitwhen tree.right == 0
					set tree = tree.right
				endloop
				
				set tree.next = node
				set node.prev = tree
			endmethod
			
			/*
			*	Splits a tree, returning the left piece
			*/
			method splitLeft takes nothing returns Node
				local thistype left = this.left
				
				debug call ThrowError(left == 0, "BooleanExpression.NodeExpressionScope", "splitLeft", "Node", this, "Attempted To Split Node, Expecting Tree.")
				debug call ThrowError(root != 0, "BooleanExpression.NodeExpressionScope", "splitLeft", "Node", this, "Attempted To Split Child Tree, Expecting Tree.")
				
				if (canDestroy) then
					set canDestroy = false
					call DestroyBoolExpr(expression)
				endif
				
				call expression_clear()
				
				set right.root = 0
				set left.root = 0
				set this.left = 0
				set right = 0
				
				call deallocate()
				
				return left
			endmethod
			
			/*
			*	Returns malformed tree or 0
			*	Takes a node
			*/
			method remove takes nothing returns Node
				local thistype node = next
				
				local thistype nextRoot = next.root
				local thistype currentRoot = root
				
				local boolean isRight = currentRoot.right == this
				
				local thistype lastNode = 0
				
				local thistype replacer
				
				debug call ThrowError(left != 0 or right != 0, "BooleanExpression.NodeExpressionScope", "remove", "Node", this, "Attempted To Remove Tree, Expecting Node.")
				
				if (node != 0) then
					loop
						set lastNode = node
						
						set node.root = currentRoot
						
						/*
						*	Set new child of root
						*/
						if (currentRoot != 0) then
							if (isRight) then
								set currentRoot.right = node
							else
								set currentRoot.left = node
							endif
							
							set isRight = not isRight
						endif
						
						/*
						*	Replace boolean expressions along tree
						*/
						set replacer = node.root
						loop
							exitwhen replacer == 0
							
							if (replacer.canDestroy) then
								set replacer.canDestroy = false
								call DestroyBoolExpr(replacer.expression)
							endif
							
							if (replacer.right.expression == null) then
								if (replacer.left.expression == null) then
									call replacer.expression_clear()
								else
									set replacer.expression = replacer.left.expression
								endif
							elseif (replacer.left.expression == null) then
								set replacer.expression = replacer.right.expression
							else
								set replacer.canDestroy = true
								set replacer.expression = Or(replacer.left.expression, replacer.right.expression)
							endif
							
							set replacer = replacer.root
						endloop
						
						set currentRoot = nextRoot
						set node = node.next
						exitwhen node == 0
						set nextRoot = node.root
					endloop
					
					/*
					*	Clear Last Position If There Is One
					*/
					if (currentRoot != 0) then
						if (isRight) then
							set currentRoot.right = 0
						else
							set currentRoot.left = 0
						endif
					endif
					
					/*
					*	Remove from list
					*/
					set next.prev = prev
					
					if (prev != 0) then
						set prev.next = next
						set prev = 0
					endif
					
					set next = 0
				elseif (prev != 0) then
					/*
					*	Remove from list partial
					*/
					set prev.next = next
					set prev = 0
				endif
				
				/*
				*	Get last added tree (may be removed null)
				*/
				if (lastNode == 0) then
					set lastNode = root
				endif
				loop
					exitwhen lastNode.root == 0
					set lastNode = lastNode.root
				endloop
				
				/*
				*	Remove from tree
				*/
				if (root.left == this) then
					set root.left = 0
				elseif (root.right == this) then
					set root.right = 0
				endif
				set root = 0
				
				/*
				*	Destroy removed node
				*/
				call expression_clear()
				
				call deallocate()
				
				/*
				*	Return last added tree
				*/
				return lastNode
			endmethod
			
			method removeReverse takes nothing returns Node
				local thistype node = next
				
				local thistype nextRoot = next.root
				local thistype currentRoot = root
				
				local boolean isRight = currentRoot.right == this
				
				local thistype lastNode = 0
				
				local thistype replacer
				
				debug call ThrowError(left != 0 or right != 0, "BooleanExpression.NodeExpressionScope", "remove", "Node", this, "Attempted To Remove Tree, Expecting Node.")
				
				static if DEBUG_LOG then
					call print("removeReverse: " + I2S(id))
				endif
				
				if (node != 0) then
					loop
						set lastNode = node
						
						set node.root = currentRoot
						
						/*
						*	Set new child of root
						*/
						if (currentRoot != 0) then
							if (isRight) then
								set currentRoot.right = node
							else
								set currentRoot.left = node
							endif
							
							set isRight = not isRight
						endif
						
						/*
						*	Replace boolean expressions along tree
						*/
						set replacer = node.root
						loop
							exitwhen replacer == 0
							
							if (replacer.canDestroy) then
								set replacer.canDestroy = false
								call DestroyBoolExpr(replacer.expression)
							endif
							
							if (replacer.right.expression == null) then
								if (replacer.left.expression == null) then
									call replacer.expression_clear()
								else
									set replacer.expression = replacer.left.expression
								endif
							elseif (replacer.left.expression == null) then
								set replacer.expression = replacer.right.expression
							else
								set replacer.canDestroy = true
								set replacer.expression = Or(replacer.right.expression, replacer.left.expression)
							endif
							
							set replacer = replacer.root
						endloop
						
						set currentRoot = nextRoot
						set node = node.next
						exitwhen node == 0
						set nextRoot = node.root
					endloop
					
					/*
					*	Clear Last Position If There Is One
					*/
					if (currentRoot != 0) then
						if (isRight) then
							set currentRoot.right = 0
						else
							set currentRoot.left = 0
						endif
					endif
					
					/*
					*	Remove from list
					*/
					set next.prev = prev
					
					if (prev != 0) then
						set prev.next = next
						set prev = 0
					endif
					
					set next = 0
				elseif (prev != 0) then
					/*
					*	Remove from list partial
					*/
					set prev.next = next
					set prev = 0
				endif
				
				/*
				*	Get last added tree (may be removed null)
				*/
				if (lastNode == 0) then
					set lastNode = root
				endif
				loop
					exitwhen lastNode.root == 0
					set lastNode = lastNode.root
				endloop
				
				/*
				*	Remove from tree
				*/
				if (root.left == this) then
					set root.left = 0
				elseif (root.right == this) then
					set root.right = 0
				endif
				set root = 0
				
				/*
				*	Destroy removed node
				*/
				call expression_clear()
				
				call deallocate()
				
				/*
				*	Return last added tree
				*/
				
				static if DEBUG_LOG then
					call print("removeReverse Result: " + lastNode.toString())
				endif
				
				return lastNode
			endmethod
			
			method replace takes boolexpr expression returns nothing
				if (expression == null) then
					call this.expression_clear()
				else
					set this.expression = expression
				endif
				loop
					exitwhen root == 0
					set this = root
					
					if (this.canDestroy) then
						set this.canDestroy = false
						call DestroyBoolExpr(this.expression)
					endif
					if (right.expression == null) then
						if (left.expression == null) then
							call this.expression_clear()
						else
							set this.expression = left.expression
						endif
					elseif (left.expression == null) then
						set this.expression = right.expression
					else
						set this.canDestroy = true
						set this.expression = Or(left.expression, right.expression)
					endif
				endloop
			endmethod
			
			method replaceReverse takes boolexpr expression returns nothing
				static if DEBUG_LOG then
					call print("replaceReverse: " + I2S(id))
				endif
			
				if (expression == null) then
					call this.expression_clear()
				else
					set this.expression = expression
				endif
				loop
					exitwhen root == 0
					set this = root
					
					if (this.canDestroy) then
						set this.canDestroy = false
						call DestroyBoolExpr(this.expression)
					endif
					if (right.expression == null) then
						if (left.expression == null) then
							call this.expression_clear()
						else
							set this.expression = left.expression
						endif
					elseif (left.expression == null) then
						set this.expression = right.expression
					else
						set this.canDestroy = true
						set this.expression = Or(right.expression, left.expression)
					endif
				endloop
			endmethod
			
			private static method init takes nothing returns nothing
				//! runtextmacro INITIALIZE_TABLE_FIELD("root")
				//! runtextmacro INITIALIZE_TABLE_FIELD("left")
				//! runtextmacro INITIALIZE_TABLE_FIELD("right")
				//! runtextmacro INITIALIZE_TABLE_FIELD("next")
				//! runtextmacro INITIALIZE_TABLE_FIELD("prev")
				//! runtextmacro INITIALIZE_TABLE_FIELD("expression")
				//! runtextmacro INITIALIZE_TABLE_FIELD("canDestroy")
				//! runtextmacro INITIALIZE_TABLE_FIELD("reversed")
				//! runtextmacro INITIALIZE_TABLE_FIELD("list")
			endmethod
			
			static if DEBUG_LOG then
				method toString takes nothing returns string
					if (this == 0) then
						return ""
					endif
					
					if (left != 0 or right != 0) then
						return "(" + left.toString() + ")" + I2S(id) + "R(" + right.toString() + ")"
					else
						return "(" + left.toString() + ")" + I2S(id) + "C(" + right.toString() + ")"
					endif
				endmethod
			endif
			
			implement Init
		endstruct
		
		struct NodeExpression extends array
			method operator root takes nothing returns thistype
				return Node(this).root
			endmethod
			method operator left takes nothing returns thistype
				return Node(this).left
			endmethod
			method operator right takes nothing returns thistype
				return Node(this).right
			endmethod
			method operator next takes nothing returns thistype
				return Node(this).next
			endmethod
			method operator prev takes nothing returns thistype
				return Node(this).prev
			endmethod
			method operator expression takes nothing returns boolexpr
				return Node(this).expression
			endmethod
			method operator expression= takes boolexpr expression returns nothing
				set Node(this).expression = expression
			endmethod
			
			static method create takes ListExpression list, boolean reversed, boolexpr expression returns thistype
				local Node node = Node.create(list, reversed)
				set node.expression = expression
				return node
			endmethod
			method destroy takes nothing returns nothing
				call Node(this).destroySub()
			endmethod
			
			static method join takes Node left, Node right returns thistype
				return Node.join(left, right)
			endmethod
			static method joinReverse takes Node left, Node right returns thistype
				return Node.joinReverse(left, right)
			endmethod
			static method listJoin takes Node prev, Node next returns nothing
				call Node.listJoin(prev, next)
			endmethod
			
			method splitLeft takes nothing returns thistype
				return Node(this).splitLeft()
			endmethod
			
			method remove takes nothing returns thistype
				return Node(this).remove()
			endmethod
			method removeReverse takes nothing returns thistype
				return Node(this).removeReverse()
			endmethod
			
			method operator top takes nothing returns thistype
				loop
					exitwhen Node(this).root == 0
					set this = Node(this).root
				endloop
				
				return this
			endmethod
			method replace takes boolexpr expression returns nothing
				call Node(this).replace(expression)
			endmethod
			method replaceReverse takes boolexpr expression returns nothing
				call Node(this).replaceReverse(expression)
			endmethod
			
			static if DEBUG_MODE then
				static method calculateMemoryUsage takes nothing returns integer
					return Node.calculateMemoryUsage()
				endmethod
				
				static method getAllocatedMemoryAsString takes nothing returns string
					return Node.getAllocatedMemoryAsString()
				endmethod
			endif
		endstruct
		
		scope ListExpressionScope
			private keyword List_P
			//! runtextmacro CREATE_TABLE_FIELD_ARRAY("integer", "expressionOwner", "List_P")
			
			private struct List_P extends array
				//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "expression", "NodeExpression")
				//! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "reversed", "boolean")
				//! runtextmacro USE_TABLE_FIELD_ARRAY("public", "expressionOwner")
				
				implement ListT
				
				private static method init takes nothing returns nothing
					//! runtextmacro INITIALIZE_TABLE_FIELD("expression")
					//! runtextmacro INITIALIZE_TABLE_FIELD("reversed")
				endmethod
				
				implement Init
			endstruct
			
			struct ListExpression extends array
				static method operator sentinel takes nothing returns integer
					return List_P.sentinel
				endmethod
				method operator list takes nothing returns thistype
					return List_P(this).list
				endmethod
				method operator first takes nothing returns thistype
					return List_P(this).first
				endmethod
				method operator last takes nothing returns thistype
					return List_P(this).last
				endmethod
				method operator next takes nothing returns thistype
					return List_P(this).next
				endmethod
				method operator prev takes nothing returns thistype
					return List_P(this).prev
				endmethod
				method operator expression takes nothing returns boolexpr
					return List_P(this).expression.expression
				endmethod
				method operator reversed takes nothing returns boolean
					return List_P(this).reversed
				endmethod
				
				/*
				*	Destroy all trees in list
				*/
				private method clearExpressions takes nothing returns nothing
					local thistype node = first
					
					loop
						exitwhen node == 0
						
						if (List_P(node).expression != 0) then
							call List_P(node).expression.destroy()
							set List_P(node).expression = 0
						endif
						
						set node = node.next
					endloop
				endmethod
				
				static method create takes boolean reverse returns thistype
					local thistype this = List_P.create()
					set List_P(this).reversed = reverse
					call List_P(this).enqueue()
					
					return this
				endmethod
				
				method destroy takes nothing returns nothing
					call clearExpressions()
					set List_P(this).reversed = false
					call List_P(this).destroy()
				endmethod
				
				method clear takes nothing returns nothing
					call clearExpressions()
					call List_P(this).clear()
					call List_P(this).enqueue()
				endmethod
				
				private method operator firstExpression takes nothing returns NodeExpression
					loop
						exitwhen this == 0 or List_P(this).expression != 0
						set this = next
					endloop
					
					return List_P(this).expression
				endmethod
				
				private method insertRegular takes boolexpr expression returns thistype
					local List_P node = first
					local NodeExpression nodeExpression = NodeExpression.create(this, false, expression)
					local NodeExpression firstExpression = thistype(node).firstExpression
					
					if (firstExpression != 0) then
						call NodeExpression.listJoin(firstExpression, nodeExpression)
					endif
					
					/*
					*	If the first node on the list has no expression put expression in node
					*/
					if (node.expression == 0) then
						set node.expression = nodeExpression
						set List_P.expressionOwner[nodeExpression] = node
					/*
					*	If it does have an expression, join expressions
					*/
					else
						set node.expression = NodeExpression.join(node.expression, nodeExpression)
						
						loop
							exitwhen node.next == 0 or node.next.expression == 0
							
							set node.next.expression = NodeExpression.join(node.next.expression, node.expression)
							set node.expression = 0
							
							set node = node.next
						endloop
						
						if (node.next == 0) then
							set List_P(this).enqueue().expression = node.expression
						else
							set node.next.expression = node.expression
						endif
						
						set node.expression = 0
					endif
					
					/*
					*	Used to remove expressions
					*/
					set List_P.expressionOwner[node.next.expression] = node.next
					
					return nodeExpression
				endmethod
				
				private method insertReverse takes boolexpr expression returns thistype
					local List_P node = first
					local NodeExpression nodeExpression = NodeExpression.create(this, true, expression)
					local NodeExpression firstExpression = thistype(node).firstExpression
					
					if (firstExpression != 0) then
						call NodeExpression.listJoin(firstExpression, nodeExpression)
					endif
					
					/*
					*	If the first node on the list has no expression put expression in node
					*/
					if (node.expression == 0) then
						set node.expression = nodeExpression
						set List_P.expressionOwner[nodeExpression] = node
					/*
					*	If it does have an expression, join expressions
					*/
					else
						set node.expression = NodeExpression.joinReverse(node.expression, nodeExpression)
						
						loop
							exitwhen node.next == 0 or node.next.expression == 0
							
							set node.next.expression = NodeExpression.joinReverse(node.next.expression, node.expression)
							set node.expression = 0
							
							set node = node.next
						endloop
						
						if (node.next == 0) then
							set List_P(this).enqueue().expression = node.expression
						else
							set node.next.expression = node.expression
						endif
						
						set node.expression = 0
					endif
					
					/*
					*	Used to remove expressions
					*/
					set List_P.expressionOwner[node.next.expression] = node.next
					
					return nodeExpression
				endmethod
				
				method insert takes boolexpr expression returns thistype
					if (List_P(this).reversed) then
						return insertReverse(expression)
					endif
					
					return insertRegular(expression)
				endmethod
				
				/*
				*	Return owning list
				*/
				private method removeRegular takes nothing returns thistype
					local NodeExpression node = this
					local NodeExpression tree = node.top
					local List_P listNode = List_P.expressionOwner[tree]
					local List_P owner = listNode.list
					
					local boolean isOdd = listNode.list.first.expression != 0	//no need to decompose when odd
					
					set node = node.remove()
					
					if (isOdd) then
						set listNode.list.first.expression = 0
					
						return owner
					else
						/*
						*	Decompose the tree
						*/
						set listNode = List_P.expressionOwner[node.top]
						set listNode.expression = 0
						
						loop
							exitwhen node.left == 0
							set tree = node.right
							set node = node.splitLeft()
							set listNode = listNode.prev
							set listNode.expression = node
							set List_P.expressionOwner[node] = listNode
							set node = tree
						endloop
						
						if (node != 0) then
							set listNode = listNode.prev
							set listNode.next.expression = node
							set List_P.expressionOwner[node] = listNode
						endif
					endif
					
					return owner
				endmethod
				
				private method removeReverse takes nothing returns thistype
					local NodeExpression node = this
					local NodeExpression tree = node.top
					local List_P listNode = List_P.expressionOwner[tree]
					local List_P owner = listNode.list
					
					local boolean isOdd = listNode.list.first.expression != 0	//no need to decompose when odd
					
					set node = node.removeReverse()
					
					if (isOdd) then
						set listNode.list.first.expression = 0
					
						return owner
					else
						/*
						*	Decompose the tree
						*/
						set listNode = List_P.expressionOwner[node.top]
						set listNode.expression = 0
						
						loop
							exitwhen node.left == 0
							set tree = node.right
							set node = node.splitLeft()
							set listNode = listNode.prev
							set listNode.expression = node
							set List_P.expressionOwner[node] = listNode
							set node = tree
						endloop
						
						if (node != 0) then
							set listNode = listNode.prev
							set listNode.next.expression = node
							set List_P.expressionOwner[node] = listNode
						endif
					endif
					
					return owner
				endmethod
				
				method remove takes nothing returns thistype
					if (Node(this).reversed) then
						return removeReverse()
					endif
					
					return removeRegular()
				endmethod
				
				private method replaceRegular takes boolexpr expression returns thistype
					call NodeExpression(this).replace(expression)
					return Node(this).list
					//return List_P.expressionOwner[NodeExpression(this).top].list
				endmethod
				private method replaceReverse takes boolexpr expression returns thistype
					call NodeExpression(this).replaceReverse(expression)
					return Node(this).list
					//return List_P.expressionOwner[NodeExpression(this).top].list
				endmethod
				method replace takes boolexpr expression returns thistype
					if (Node(this).reversed) then
						return replaceReverse(expression)
					endif
					
					return replaceRegular(expression)
				endmethod
				
				static if DEBUG_MODE then
					static method calculateMemoryUsage takes nothing returns integer
						return List_P.calculateMemoryUsage()
					endmethod
					
					static method getAllocatedMemoryAsString takes nothing returns string
						return List_P.getAllocatedMemoryAsString()
					endmethod
				endif
				
				static if DEBUG_LOG then
					method toString takes nothing returns string
						local thistype node = first
						local string s = ""
						
						loop
							exitwhen node == 0
							
							if (s != "") then
								set s = s + " , "
							endif
							
							if (List_P(node).expression == 0) then
								set s = s + "D"
							else
								set s = s + Node(List_P(node).expression).toString()
							endif
							
							set node = node.next
						endloop
						
						return s
					endmethod
				endif
			endstruct
		endscope
	endscope
	
	//! runtextmacro CREATE_TABLE_FIELD_ARRAY("boolexpr", "buffer", "boolexpr")
	private struct BooleanExpressionContainer extends array
		implement NxStackT
		
		//! runtextmacro CREATE_TABLE_FIELD("private", "boolexpr", "expression", "boolexpr")
		//! runtextmacro CREATE_TABLE_FIELD("public", "boolexpr", "top", "boolexpr")
		
		/*
		*	Move the list to an array
		*
		*	Merge slots on the array in pairs
		*/
		//! runtextmacro USE_TABLE_FIELD_ARRAY("private", "buffer")
		private method buildRegular takes nothing returns nothing
			local ListExpression node = ListExpression(this).last
			
			local integer length = 0
			local integer positionStart = 0
			local integer positionEnd
			
			/*
			*	Get length
			*/
			loop
				exitwhen node == 0
				if (node.expression != null) then
					set length = length + 1
				endif
				set node = node.prev
			endloop
			if (length == 0) then
				call top_clear()
			
				return
			endif
			set positionEnd = length
			
			/*
			*	Copy to array
			*/
			set node = ListExpression(this).last
			loop
				exitwhen positionStart == positionEnd
				
				loop
					exitwhen node.expression != null
					set node = node.prev
				endloop
				set buffer[positionStart] = node.expression
				set positionStart = positionStart + 1
				
				
				exitwhen positionStart == positionEnd
				loop
					set node = node.prev
					exitwhen node.expression != null
				endloop
				set positionEnd = positionEnd - 1
				set buffer[positionEnd] = node.expression
				
				set node = node.prev
			endloop
			
			/*
			*	Merge
			*/
			loop
				exitwhen length < 2
				
				set positionStart = 0
				set positionEnd = length - 1
				loop
					set buffer[positionStart] = Or(buffer[positionStart], buffer[positionEnd])
					set push().expression = buffer[positionStart]
					set positionStart = positionStart + 1
					set positionEnd = positionEnd - 1
					
					exitwhen positionStart >= positionEnd
				endloop
				
				if (length - length/2*2 == 0) then
					set length = length/2
				else
					set length = length/2 + 1
				endif
			endloop
			
			set top = buffer[0]
			
			call buffer.clear()
		endmethod
		
		private method buildReverse takes nothing returns nothing
			local ListExpression node = ListExpression(this).last
			
			local integer length = 0
			local integer positionStart = 0
			local integer positionEnd
			
			/*
			*	Get length
			*/
			loop
				exitwhen node == 0
				if (node.expression != null) then
					set length = length + 1
				endif
				set node = node.prev
			endloop
			if (length == 0) then
				call top_clear()
			
				return
			endif
			set positionEnd = length
			
			/*
			*	Copy to array
			*/
			set node = ListExpression(this).last
			loop
				exitwhen positionStart == positionEnd
				
				loop
					exitwhen node.expression != null
					set node = node.prev
				endloop
				set buffer[positionStart] = node.expression
				set positionStart = positionStart + 1
				
				
				exitwhen positionStart == positionEnd
				loop
					set node = node.prev
					exitwhen node.expression != null
				endloop
				set positionEnd = positionEnd - 1
				set buffer[positionEnd] = node.expression
				
				set node = node.prev
			endloop
			
			/*
			*	Merge
			*/
			loop
				exitwhen length < 2
				
				set positionStart = 0
				set positionEnd = length - 1
				loop
					set buffer[positionStart] = Or(buffer[positionEnd], buffer[positionStart])
					set push().expression = buffer[positionStart]
					set positionStart = positionStart + 1
					set positionEnd = positionEnd - 1
					
					exitwhen positionStart >= positionEnd
				endloop
				
				if (length - length/2*2 == 0) then
					set length = length/2
				else
					set length = length/2 + 1
				endif
			endloop
			
			set top = buffer[0]
			
			call buffer.clear()
		endmethod
		
		method build takes nothing returns nothing
			if (ListExpression(this).reversed) then
				call buildReverse()
			else
				call buildRegular()
			endif
		endmethod
		
		method destruct takes nothing returns nothing
			local thistype stack = this
			
			call top_clear()
			set this = first
			
			loop
				exitwhen this == 0
				call DestroyBoolExpr(expression)
				call expression_clear()
				set this = next
			endloop
			
			call stack.clear()
		endmethod
		
		private static method init takes nothing returns nothing
			//! runtextmacro INITIALIZE_TABLE_FIELD("expression")
			//! runtextmacro INITIALIZE_TABLE_FIELD("top")
		endmethod
		
		implement Init
	endstruct
	
	struct BooleanExpression extends array
		//! runtextmacro CREATE_TABLE_FIELD("private", "boolean", "modified", "boolean")
		
		static if DEBUG_MODE then
			//! runtextmacro CREATE_TABLE_FIELD("private", "boolean", "isAllocated", "boolean")
		endif
		
		/*
		*	Only rebuild the expression when it is needed, otherwise leave it alone
		*	Rebuilding the expression will break triggers using it plus has a bit of overhead
		*/
		method operator expression takes nothing returns boolexpr
			debug call ThrowError(this == 0,		"BooleanExpression", "expression", "BooleanExpression", this, "Attempted To Read Null Boolean Expression.")
			debug call ThrowError(not isAllocated,	"BooleanExpression", "expression", "BooleanExpression", this, "Attempted To Read Invalid Boolean Expression.")
		
			if (modified) then
				set modified = false
				call BooleanExpressionContainer(this).destruct()
				call BooleanExpressionContainer(this).build()
			endif
			
			return BooleanExpressionContainer(this).top
		endmethod
	
		static method create takes boolean reversed returns thistype
			local thistype this = ListExpression.create(reversed)
			
			call BooleanExpressionContainer(this).clear()
			
			debug set isAllocated = true
			
			return this
		endmethod
		method destroy takes nothing returns nothing
			debug call ThrowError(this == 0,		"BooleanExpression", "destroy", "BooleanExpression", this, "Attempted To Destroy Null Boolean Expression.")
			debug call ThrowError(not isAllocated,	"BooleanExpression", "destroy", "BooleanExpression", this, "Attempted To Destroy Invalid Boolean Expression.")
		
			debug set isAllocated = false
			set modified = false
			call BooleanExpressionContainer(this).destruct()
			call BooleanExpressionContainer(this).destroy()
			call ListExpression(this).destroy()
		endmethod
		
		method clear takes nothing returns nothing
			debug call ThrowError(this == 0,		"BooleanExpression", "clear", "BooleanExpression", this, "Attempted To Clear Null Boolean Expression.")
			debug call ThrowError(not isAllocated,	"BooleanExpression", "clear", "BooleanExpression", this, "Attempted To Clear Invalid Boolean Expression.")
		
			set modified = false
			call BooleanExpressionContainer(this).destruct()
			call ListExpression(this).clear()
		endmethod
		
		method register takes boolexpr expression returns thistype
			debug call ThrowError(this == 0,		"BooleanExpression", "register", "BooleanExpression", this, "Attempted To Register To Null Boolean Expression.")
			debug call ThrowError(not isAllocated,	"BooleanExpression", "register", "BooleanExpression", this, "Attempted To Register To Invalid Boolean Expression.")
			
			set modified = true
			return ListExpression(this).insert(expression)
		endmethod
		method unregister takes nothing returns nothing
			/*
			*	No easy way to do error checking here, will have to let internal resources do it
			*/
			set thistype(ListExpression(this).remove()).modified= true
		endmethod
		
		method replace takes boolexpr expression returns nothing
			set thistype(ListExpression(this).replace(expression)).modified = true
		endmethod
		
		static if DEBUG_MODE then
			static method calculateMemoryUsage takes nothing returns integer
				return NodeExpression.calculateMemoryUsage() + BooleanExpressionContainer.calculateMemoryUsage() + ListExpression.calculateMemoryUsage()
			endmethod
			
			static method getAllocatedMemoryAsString takes nothing returns string
				return "(Node Expression)[" + NodeExpression.getAllocatedMemoryAsString() + "], (List Expression)[" + ListExpression.getAllocatedMemoryAsString() + "], (Boolean Expression Container)[" + BooleanExpressionContainer.getAllocatedMemoryAsString() + "]"
			endmethod
		endif
		
		static if DEBUG_LOG then
			method toString takes nothing returns string
				return ListExpression(this).toString()
			endmethod
			
			method dump takes nothing returns nothing
				call print(toString())
			endmethod
		endif
		
		private static method init takes nothing returns nothing
			//! runtextmacro INITIALIZE_TABLE_FIELD("modified")
			
			static if DEBUG_MODE then
				//! runtextmacro INITIALIZE_TABLE_FIELD("isAllocated")
			endif
		endmethod
		
		implement Init
	endstruct
endlibrary//===========================================================================
// Trigger: Trigger
//===========================================================================
library Trigger /* v1.1.0.1
************************************************************************************
*
*   */ uses /*
*   
*       */ ErrorMessage         /*
*       */ BooleanExpression    /*
*       */ NxListT              /*
*		*/ UniqueNxListT		/*
*       */ Init                 /*
*
************************************************************************************
*
*   struct Trigger extends array
*           
*       Fields
*       -------------------------
*
*           readonly trigger trigger
*               -   use to register events, nothing else
*               -   keep in mind that triggers referencing this trigger won't fire when events fire
*               -   this trigger will fire when triggers referencing this trigger are fired
*
*           boolean enabled
*
*       Methods
*       -------------------------
*
*           static method create takes boolean reversed returns Trigger
*				-	when reverse is true, the entire expression is run in reverse
*
*           method destroy takes nothing returns nothing
*
*           method register takes boolexpr expression returns TriggerCondition
*
*           method reference takes Trigger trig returns TriggerReference
*               -   like register, but for triggers instead
*
*           method fire takes nothing returns nothing
*
*           method clear takes nothing returns nothing
*               -   clears expressions
*           method clearReferences takes nothing returns nothing
*               -   clears trigger references
*           method clearBackReferences takes nothing returns nothing
*               -   removes references for all triggers referencing this trigger
*           method clearEvents takes nothing returns nothing
*               -   clears events
*
*           debug static method calculateMemoryUsage takes nothing returns integer
*           debug static method getAllocatedMemoryAsString takes nothing returns string
*
************************************************************************************
*
*   struct TriggerReference extends array
*           
*       Methods
*       -------------------------
*
*           method destroy takes nothing returns nothing
*
*           method replace takes Trigger trigger returns nothing
*
************************************************************************************
*
*   struct TriggerCondition extends array
*
*       Methods
*       -------------------------
*
*           method destroy takes nothing returns nothing
*
*           method replace takes boolexpr expr returns nothing
*
************************************************************************************/
    private struct TriggerMemory extends array
        //! runtextmacro CREATE_TABLE_FIELD("public", "trigger", "trig", "trigger")
        //! runtextmacro CREATE_TABLE_FIELD("public", "triggercondition", "tc", "triggercondition")
        
        //! runtextmacro CREATE_TABLE_FIELD("public", "integer", "expression", "BooleanExpression")                 //the trigger's expression
        
        //! runtextmacro CREATE_TABLE_FIELD("public", "boolean", "enabled", "boolean")
        
        method updateTrigger takes nothing returns nothing
            if (tc != null) then
                call TriggerRemoveCondition(trig, tc)
            endif
        
            if (enabled and expression.expression != null) then
                set tc = TriggerAddCondition(trig, expression.expression)
            else
				call tc_clear()
            endif
        endmethod
        
        private static method init takes nothing returns nothing
            //! runtextmacro INITIALIZE_TABLE_FIELD("trig")
            //! runtextmacro INITIALIZE_TABLE_FIELD("tc")
            
            //! runtextmacro INITIALIZE_TABLE_FIELD("expression")
            
            //! runtextmacro INITIALIZE_TABLE_FIELD("enabled")
        endmethod
        
        implement Init
    endstruct

    private struct TriggerAllocator extends array
        implement AllocT
    endstruct
    
    private keyword TriggerReferencedList
    
    private struct TriggerReferenceListData extends array
        //! runtextmacro CREATE_TABLE_FIELD("public", "integer", "trig", "TriggerMemory")           //the referenced trigger
        //! runtextmacro CREATE_TABLE_FIELD("public", "integer", "ref", "TriggerReferencedList")    //the TriggerReferencedList data for that trigger (relationship in 2 places)
        //! runtextmacro CREATE_TABLE_FIELD("public", "integer", "expr", "BooleanExpression")
    
        implement NxListT
        
        private static method init takes nothing returns nothing
            //! runtextmacro INITIALIZE_TABLE_FIELD("trig")
            //! runtextmacro INITIALIZE_TABLE_FIELD("ref")
            //! runtextmacro INITIALIZE_TABLE_FIELD("expr")
        endmethod
        
        implement Init
    endstruct

    /*
    *   List of triggers referencing current trigger
    */
    private struct TriggerReferencedList extends array
        //! runtextmacro CREATE_TABLE_FIELD("public", "integer", "trig", "TriggerMemory")               //the trigger referencing this trigger
        //! runtextmacro CREATE_TABLE_FIELD("public", "integer", "ref", "TriggerReferenceListData")     //the ref 
    
        implement NxListT
        
        method updateExpression takes nothing returns nothing
            local thistype node
            local boolexpr expr
            
            /*
            *   Retrieve the expression of the referenced trigger
            */
            if (TriggerMemory(this).enabled) then
                set expr = TriggerMemory(this).expression.expression
            else
                set expr = null
            endif
            
            /*
            *   Iterate over all triggers referencing this trigger
            */
            set node = first
            loop
                exitwhen node == 0
                
                /*
                *   Replace expression and then update the target trigger
                */
                call node.ref.expr.replace(expr)
                call node.trig.updateTrigger()
                call TriggerReferencedList(node.trig).updateExpression()
                
                set node = node.next
            endloop
            
            set expr = null
        endmethod
        
        method purge takes nothing returns nothing
            local thistype node = first
            
            loop
                exitwhen node == 0
                
                /*
                *   Unregister the expression from the referencing trigger
                *   Update that trigger
                */
                call node.ref.expr.unregister()
                call node.trig.updateTrigger()
                call node.ref.remove()
                call TriggerReferencedList(node.trig).updateExpression()
                
                set node = node.next
            endloop
            
            call destroy()
        endmethod
        
        method clearReferences takes nothing returns nothing
            local thistype node = first
            
            loop
                exitwhen node == 0
                
                /*
                *   Unregister the expression from the referencing trigger
                *   Update that trigger
                */
                call node.ref.expr.unregister()
                call node.trig.updateTrigger()
                call node.ref.remove()
                call TriggerReferencedList(node.trig).updateExpression()
                
                set node = node.next
            endloop
            
            call clear()
        endmethod
        
        private static method init takes nothing returns nothing
            //! runtextmacro INITIALIZE_TABLE_FIELD("trig")
            //! runtextmacro INITIALIZE_TABLE_FIELD("ref")
        endmethod
        
        implement Init
    endstruct
    
    /*
    *   List of triggers current trigger references
    */
    private struct TriggerReferenceList extends array
        method add takes TriggerReferencedList trig returns thistype
            local TriggerReferenceListData node = TriggerReferenceListData(this).enqueue()
            
            /*
            *   Register the trigger as a reference
            */
            set node.trig = trig
            set node.ref = TriggerReferencedList(trig).enqueue()
            set node.ref.trig = this
            set node.ref.ref = node
            
            /*
            *   Add the reference's expression
            *
            *   Add even if null to ensure correct order
            */
            if (TriggerMemory(trig).enabled) then
                set node.expr = TriggerMemory(this).expression.register(TriggerMemory(trig).expression.expression)
            else
				set node.expr = TriggerMemory(this).expression.register(null)
            endif
            
            call TriggerMemory(this).updateTrigger()
            
            /*
            *   Update the expressions of triggers referencing this trigger
            */
            call TriggerReferencedList(this).updateExpression()
            
            /*
            *   Return the reference
            */
            return node
        endmethod
        
        method erase takes nothing returns nothing
            local TriggerReferenceListData node = this          //the node
            set this = node.ref.trig                            //this trigger        
            
            call node.expr.unregister()
            call TriggerMemory(this).updateTrigger()
            call TriggerReferencedList(this).updateExpression()
            
            call node.ref.remove()
            call node.remove()
        endmethod
        
        method replace takes TriggerMemory trig returns nothing
            local TriggerReferenceListData node = this
            set this = node.list
            
            call node.ref.remove()
            
            set node.trig = trig
            set node.ref = TriggerReferencedList(trig).enqueue()
            set node.ref.trig = this
            set node.ref.ref = node
            
            if (trig.enabled) then
                call node.expr.replace(trig.expression.expression)
            else
                call node.expr.replace(null)
            endif
            
            call TriggerMemory(this).updateTrigger()
            
            call TriggerReferencedList(this).updateExpression()
        endmethod
        
        /*
        *   Purges all references
        */
        method purge takes nothing returns nothing
            local TriggerReferenceListData node = TriggerReferenceListData(this).first
            
            loop
                exitwhen node == 0
                
                /*
                *   Removes the reference from the referenced list
                *   (triggers no longer referenced by this)
                */
                call node.ref.remove()
                
                set node = node.next
            endloop
            
            /*
            *   Destroy all references by triggers referencing this
            */
            call TriggerReferencedList(this).purge()
            
            call TriggerReferenceListData(this).destroy()
        endmethod
        
        method clearReferences takes nothing returns nothing
            local TriggerReferenceListData node = TriggerReferenceListData(this).first
            
            loop
                exitwhen node == 0
                
                /*
                *   Removes the reference from the referenced list
                *   (triggers no longer referenced by this)
                */
                call node.ref.remove()
				
				/*
				*	unregisters code
				*/
				call node.expr.unregister()
                
                set node = node.next
            endloop
            
            call TriggerReferenceListData(this).clear()
        endmethod
    endstruct
    
    private struct TriggerReferenceData extends array
        static if DEBUG_MODE then
            //! runtextmacro CREATE_TABLE_FIELD("private", "boolean", "isTriggerReference", "boolean")
        endif
        
        static method create takes TriggerReferenceList origin, TriggerMemory ref returns thistype
            local thistype this = origin.add(ref)
            
            debug set isTriggerReference = true
            
            return this
        endmethod
        
        method destroy takes nothing returns nothing
            debug call ThrowError(this == 0,                "Trigger", "destroy", "TriggerReferenceData", this, "Attempted To Destroy Null TriggerReferenceData.")
            debug call ThrowError(not isTriggerReference,   "Trigger", "destroy", "TriggerReferenceData", this, "Attempted To Destroy Invalid TriggerReferenceData.")
            
            debug set isTriggerReference = false
            
            call TriggerReferenceList(this).erase()
        endmethod
        
        method replace takes Trigger trig returns nothing
            debug call ThrowError(this == 0,                "Trigger", "destroy", "TriggerReferenceData", this, "Attempted To Destroy Null TriggerReferenceData.")
            debug call ThrowError(not isTriggerReference,   "Trigger", "destroy", "TriggerReferenceData", this, "Attempted To Destroy Invalid TriggerReferenceData.")
            
            call TriggerReferenceList(this).replace(trig)
        endmethod
        
        private static method init takes nothing returns nothing
            static if DEBUG_MODE then
                //! runtextmacro INITIALIZE_TABLE_FIELD("isTriggerReference")
            endif
        endmethod
        
        implement Init
    endstruct
    
	private struct TriggerConditionDataCollection extends array
		implement UniqueNxListT
	endstruct
	
    private struct TriggerConditionData extends array
        static if DEBUG_MODE then
            //! runtextmacro CREATE_TABLE_FIELD("private", "boolean", "isCondition", "boolean")
        endif
        
        //! runtextmacro CREATE_TABLE_FIELD("private", "integer", "trig", "TriggerMemory")
        
        private static method updateTrigger takes TriggerMemory trig returns nothing
            call trig.updateTrigger()
            call TriggerReferencedList(trig).updateExpression()
        endmethod
    
        static method create takes TriggerMemory trig, boolexpr expression returns thistype
            local thistype this = trig.expression.register(expression)
            
            set this.trig = trig
            
            debug set isCondition = true
			
			call TriggerConditionDataCollection(trig).enqueue(this)
            
            call updateTrigger(trig)
            
            return this
        endmethod
        
        method destroy takes nothing returns nothing
            debug call ThrowError(this == 0,        "Trigger", "destroy", "TriggerConditionData", this, "Attempted To Destroy Null TriggerConditionData.")
            debug call ThrowError(not isCondition,  "Trigger", "destroy", "TriggerConditionData", this, "Attempted To Destroy Invalid TriggerConditionData.")
            
            call BooleanExpression(this).unregister()
			
			call TriggerConditionDataCollection(this).remove()
            
            debug set isCondition = false
            
            /*
            *   Update the expression
            */
            call updateTrigger(trig)
        endmethod
        
        method replace takes boolexpr expr returns nothing
            debug call ThrowError(this == 0,        "Trigger", "destroy", "TriggerConditionData", this, "Attempted To Destroy Null TriggerConditionData.")
            debug call ThrowError(not isCondition,  "Trigger", "destroy", "TriggerConditionData", this, "Attempted To Destroy Invalid TriggerConditionData.")
            
            call BooleanExpression(this).replace(expr)
            
            call updateTrigger(trig)
        endmethod
		
        private static method init takes nothing returns nothing
            static if DEBUG_MODE then
                //! runtextmacro INITIALIZE_TABLE_FIELD("isCondition")
            endif
            
            //! runtextmacro INITIALIZE_TABLE_FIELD("trig")
        endmethod
        
        implement Init
    endstruct
    
    struct TriggerReference extends array
        method destroy takes nothing returns nothing
            call TriggerReferenceData(this).destroy()
        endmethod
        method replace takes Trigger trig returns nothing
            call TriggerReferenceData(this).replace(trig)
        endmethod
    endstruct
    
    struct TriggerCondition extends array
        method destroy takes nothing returns nothing
            call TriggerConditionData(this).destroy()
        endmethod
        method replace takes boolexpr expr returns nothing
            call TriggerConditionData(this).replace(expr)
        endmethod
    endstruct
    
    struct Trigger extends array
        static if DEBUG_MODE then
            //! runtextmacro CREATE_TABLE_FIELD("private", "boolean", "isTrigger", "boolean")
        endif
    
        static method create takes boolean reversed returns thistype
            local thistype this = TriggerAllocator.allocate()
            
            debug set isTrigger = true
            
            set TriggerMemory(this).enabled = true
            
            call TriggerReferencedList(this).clear()
            call TriggerReferenceListData(this).clear()
			call TriggerConditionDataCollection(this).clear()
            
            set TriggerMemory(this).expression = BooleanExpression.create(reversed)
            
            set TriggerMemory(this).trig = CreateTrigger()
            
            return this
        endmethod
		
		static if DEBUG_MODE then
			method destroy takes nothing returns nothing
				call destroy_p()
			endmethod
		
			private method destroy_p takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "destroy", "Trigger", this, "Attempted To Destroy Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "destroy", "Trigger", this, "Attempted To Destroy Invalid Trigger.")
				
				debug set isTrigger = false
			
				call TriggerReferenceList(this).purge()
				call TriggerConditionDataCollection(this).destroy()
				
				if (TriggerMemory(this).tc != null) then
					call TriggerRemoveCondition(TriggerMemory(this).trig, TriggerMemory(this).tc)
				endif
				call TriggerMemory(this).tc_clear()
				call DestroyTrigger(TriggerMemory(this).trig)
				call TriggerMemory(this).trig_clear()
				
				call TriggerMemory(this).expression.destroy()
				
				call TriggerAllocator(this).deallocate()
			endmethod
		else
			method destroy takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "destroy", "Trigger", this, "Attempted To Destroy Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "destroy", "Trigger", this, "Attempted To Destroy Invalid Trigger.")
				
				debug set isTrigger = false
			
				call TriggerReferenceList(this).purge()
				call TriggerConditionDataCollection(this).destroy()
				
				if (TriggerMemory(this).tc != null) then
					call TriggerRemoveCondition(TriggerMemory(this).trig, TriggerMemory(this).tc)
				endif
				call TriggerMemory(this).tc_clear()
				call DestroyTrigger(TriggerMemory(this).trig)
				call TriggerMemory(this).trig_clear()
				
				call TriggerMemory(this).expression.destroy()
				
				call TriggerAllocator(this).deallocate()
			endmethod
		endif

		static if DEBUG_MODE then
			method register takes boolexpr expression returns TriggerCondition
				return register_p(expression)
			endmethod
			private method register_p takes boolexpr expression returns TriggerCondition
				debug call ThrowError(this == 0,            "Trigger", "register", "Trigger", this, "Attempted To Register To Null Trigger.")
				debug call ThrowError(not isTrigger,        "Trigger", "register", "Trigger", this, "Attempted To Register To Invalid Trigger.")
			
				/*
				*   Register the expression
				*/
				return TriggerConditionData.create(this, expression)
			endmethod
		else
			method register takes boolexpr expression returns TriggerCondition
				debug call ThrowError(this == 0,            "Trigger", "register", "Trigger", this, "Attempted To Register To Null Trigger.")
				debug call ThrowError(not isTrigger,        "Trigger", "register", "Trigger", this, "Attempted To Register To Invalid Trigger.")
			
				/*
				*   Register the expression
				*/
				return TriggerConditionData.create(this, expression)
			endmethod
		endif
        
		static if DEBUG_MODE then
			method clear takes nothing returns nothing
				call clear_p()
			endmethod
			private method clear_p takes nothing returns nothing
				local TriggerConditionDataCollection node = TriggerConditionDataCollection(this).first
			
				debug call ThrowError(this == 0,        "Trigger", "clear", "Trigger", this, "Attempted To Clear Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clear", "Trigger", this, "Attempted To Clear Invalid Trigger.")
				
				loop
					exitwhen node == 0
					
					call BooleanExpression(node).unregister()
					
					set node = node.next
				endloop
				
				call TriggerConditionDataCollection(this).clear()
				
				call TriggerMemory(this).updateTrigger()
				call TriggerReferencedList(this).updateExpression()
			endmethod
		else
			method clear takes nothing returns nothing
				local TriggerConditionDataCollection node = TriggerConditionDataCollection(this).first
			
				debug call ThrowError(this == 0,        "Trigger", "clear", "Trigger", this, "Attempted To Clear Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clear", "Trigger", this, "Attempted To Clear Invalid Trigger.")
				
				loop
					exitwhen node == 0
					
					call BooleanExpression(node).unregister()
					
					set node = node.next
				endloop
				
				call TriggerConditionDataCollection(this).clear()
				
				call TriggerMemory(this).updateTrigger()
				call TriggerReferencedList(this).updateExpression()
			endmethod
		endif
		
		static if DEBUG_MODE then
			method clearReferences takes nothing returns nothing
				call clearReferences_p()
			endmethod
			private method clearReferences_p takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear References Of Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear References Of Invalid Trigger.")
				
				call TriggerReferenceList(this).clearReferences()
				
				call TriggerMemory(this).updateTrigger()
				call TriggerReferencedList(this).updateExpression()
			endmethod
		else
			method clearReferences takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear References Of Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear References Of Invalid Trigger.")
				
				call TriggerReferenceList(this).clearReferences()
				
				call TriggerMemory(this).updateTrigger()
				call TriggerReferencedList(this).updateExpression()
			endmethod
		endif
        
		static if DEBUG_MODE then
			method clearBackReferences takes nothing returns nothing
				call clearBackReferences_p()
			endmethod
			
			private method clearBackReferences_p takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear Back References Of Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear Back References Of Invalid Trigger.")
				
				call TriggerReferencedList(this).clearReferences()
			endmethod
		else
			method clearBackReferences takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear Back References Of Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clearReferences", "Trigger", this, "Attempted To Clear Back References Of Invalid Trigger.")
				
				call TriggerReferencedList(this).clearReferences()
			endmethod
		endif
        
		static if DEBUG_MODE then
			method reference takes thistype trig returns TriggerReference
				return reference_p(trig)
			endmethod
			
			private method reference_p takes thistype trig returns TriggerReference
				debug call ThrowError(this == 0,            "Trigger", "reference", "Trigger", this, "Attempted To Make Null Trigger Reference Trigger.")
				debug call ThrowError(not isTrigger,        "Trigger", "reference", "Trigger", this, "Attempted To Make Invalid Trigger Reference Trigger.")
				debug call ThrowError(trig == 0,            "Trigger", "reference", "Trigger", this, "Attempted To Reference Null Trigger (" + I2S(trig) + ").")
				debug call ThrowError(not trig.isTrigger,   "Trigger", "reference", "Trigger", this, "Attempted To Reference Invalid Trigger (" + I2S(trig) + ").")
				
				return TriggerReferenceData.create(this, trig)
			endmethod
		else
			method reference takes thistype trig returns TriggerReference
				debug call ThrowError(this == 0,            "Trigger", "reference", "Trigger", this, "Attempted To Make Null Trigger Reference Trigger.")
				debug call ThrowError(not isTrigger,        "Trigger", "reference", "Trigger", this, "Attempted To Make Invalid Trigger Reference Trigger.")
				debug call ThrowError(trig == 0,            "Trigger", "reference", "Trigger", this, "Attempted To Reference Null Trigger (" + I2S(trig) + ").")
				debug call ThrowError(not trig.isTrigger,   "Trigger", "reference", "Trigger", this, "Attempted To Reference Invalid Trigger (" + I2S(trig) + ").")
				
				return TriggerReferenceData.create(this, trig)
			endmethod
		endif
		
		static if DEBUG_MODE then
			method clearEvents takes nothing returns nothing
				call clearEvents_p()
			endmethod
			
			private method clearEvents_p takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "clearEvents", "Trigger", this, "Attempted To Clear Events Of Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clearEvents", "Trigger", this, "Attempted To Clear Events Of Invalid Trigger.")
			
				if (TriggerMemory(this).tc != null) then
					call TriggerRemoveCondition(TriggerMemory(this).trig, TriggerMemory(this).tc)
				endif
				call DestroyTrigger(TriggerMemory(this).trig)
				
				set TriggerMemory(this).trig = CreateTrigger()
				if (TriggerMemory(this).enabled) then
					set TriggerMemory(this).tc = TriggerAddCondition(TriggerMemory(this).trig, TriggerMemory(this).expression.expression)
				else
					call TriggerMemory(this).tc_clear()
				endif
			endmethod
		else
			method clearEvents takes nothing returns nothing
				debug call ThrowError(this == 0,        "Trigger", "clearEvents", "Trigger", this, "Attempted To Clear Events Of Null Trigger.")
				debug call ThrowError(not isTrigger,    "Trigger", "clearEvents", "Trigger", this, "Attempted To Clear Events Of Invalid Trigger.")
			
				if (TriggerMemory(this).tc != null) then
					call TriggerRemoveCondition(TriggerMemory(this).trig, TriggerMemory(this).tc)
				endif
				call DestroyTrigger(TriggerMemory(this).trig)
				
				set TriggerMemory(this).trig = CreateTrigger()
				if (TriggerMemory(this).enabled) then
					set TriggerMemory(this).tc = TriggerAddCondition(TriggerMemory(this).trig, TriggerMemory(this).expression.expression)
				else
					call TriggerMemory(this).tc_clear()
				endif
			endmethod
		endif
        
        method fire takes nothing returns nothing
            debug call ThrowError(this == 0,        "Trigger", "fire", "Trigger", this, "Attempted To Fire Null Trigger.")
            debug call ThrowError(not isTrigger,    "Trigger", "fire", "Trigger", this, "Attempted To Fire Invalid Trigger.")
        
            call TriggerEvaluate(TriggerMemory(this).trig)
        endmethod
        
        method operator trigger takes nothing returns trigger
            debug call ThrowError(this == 0,        "Trigger", "trigger", "Trigger", this, "Attempted To Read Null Trigger.")
            debug call ThrowError(not isTrigger,    "Trigger", "trigger", "Trigger", this, "Attempted To Read Invalid Trigger.")
        
            return TriggerMemory(this).trig
        endmethod
        
        method operator enabled takes nothing returns boolean
            debug call ThrowError(this == 0,                                "Trigger", "enabled", "Trigger", this, "Attempted To Read Null Trigger.")
            debug call ThrowError(not isTrigger,                            "Trigger", "enabled", "Trigger", this, "Attempted To Read Invalid Trigger.")
            
            return TriggerMemory(this).enabled
        endmethod
		
		static if DEBUG_MODE then
			method operator enabled= takes boolean enable returns nothing
				set enabled_p = enable
			endmethod
			private method operator enabled_p= takes boolean enable returns nothing
				debug call ThrowError(this == 0,                                "Trigger", "enabled=", "Trigger", this, "Attempted To Set Null Trigger.")
				debug call ThrowError(not isTrigger,                            "Trigger", "enabled=", "Trigger", this, "Attempted To Set Invalid Trigger.")
				debug call ThrowWarning(TriggerMemory(this).enabled == enable,  "Trigger", "enabled=", "Trigger", this, "Setting Enabled To Its Value.")
			
				set TriggerMemory(this).enabled = enable
				
				call TriggerMemory(this).updateTrigger()
				call TriggerReferencedList(this).updateExpression()
			endmethod
		else
			method operator enabled= takes boolean enable returns nothing
				debug call ThrowError(this == 0,                                "Trigger", "enabled=", "Trigger", this, "Attempted To Set Null Trigger.")
				debug call ThrowError(not isTrigger,                            "Trigger", "enabled=", "Trigger", this, "Attempted To Set Invalid Trigger.")
				debug call ThrowWarning(TriggerMemory(this).enabled == enable,  "Trigger", "enabled=", "Trigger", this, "Setting Enabled To Its Value.")
			
				set TriggerMemory(this).enabled = enable
				
				call TriggerMemory(this).updateTrigger()
				call TriggerReferencedList(this).updateExpression()
			endmethod
		endif
        
        static if DEBUG_MODE then
            static method calculateMemoryUsage takes nothing returns integer
                return /*
				*/	TriggerAllocator.calculateMemoryUsage() + /*
				*/	TriggerConditionDataCollection.calculateMemoryUsage() + /*
				*/	TriggerReferenceListData.calculateMemoryUsage() + /*
				*/	TriggerReferencedList.calculateMemoryUsage() + /*
				*/	BooleanExpression.calculateMemoryUsage()
            endmethod
            
            static method getAllocatedMemoryAsString takes nothing returns string
                return /*
				*/	"(Trigger)[" + TriggerAllocator.getAllocatedMemoryAsString() + "], " + /*
				*/	"(Trigger TriggerConditionDataCollection)[" + TriggerConditionDataCollection.getAllocatedMemoryAsString() + "], " + /*
				*/	"(Trigger Reference)[" + TriggerReferenceListData.getAllocatedMemoryAsString() + "], " + /*
				*/	"(Trigger Reference Back)[" + TriggerReferencedList.getAllocatedMemoryAsString() + "], " + /*
				*/	"(Boolean Expression (all))[" + BooleanExpression.getAllocatedMemoryAsString() + "]"
            endmethod
        endif
        
        private static method init takes nothing returns nothing
            static if DEBUG_MODE then
                //! runtextmacro INITIALIZE_TABLE_FIELD("isTrigger")
            endif
        endmethod
        
        implement Init
    endstruct
endlibrary//===========================================================================
// Trigger: UnitIndexer Settings
//===========================================================================
/*
*	Only use this if you are not going to use the install script
*/

/*
*	Rather than using the install script, you may copy the following ability to your map
*
*	Object Editor -> Abilities -> Unit Indexing (Unit Indexing)
*/

library UnitIndexerSettings
	globals
		constant integer ABILITIES_UNIT_INDEXER = 'A000'
	endglobals
endlibrary//===========================================================================
// Trigger: UnitIndexer
//===========================================================================
library UnitIndexer /* v5.3.0.1
************************************************************************************
*
*	*/ uses /*
*
*		*/ WorldBounds			/*
*		*/ Init					/*
*		*/ AllocQ				/*
*		*/ ErrorMessage 		/*
*		*/ ListNx 				/*
*		*/ UnitIndexerSettings 	/*
*		*/ Trigger				/*
*
********************************************************************************
*
*	struct UnitIndexer extends array
*
*		Fields
*		-------------------------
*
*			static boolean enabled
*				-	is UnitIndexer onUnitIndex enabled?
*
*			readonly static Trigger GlobalEvent.ON_INDEX
*				-	this is a global event that runs whenever any unit is indexed
*
*				Examples:	UnitIndexer.GlobalEvent.ON_INDEX.reference(yourTrigger)
*							UnitIndexer.GlobalEvent.ON_INDEX.register(yourCode)
*
*				Examples:	unitIndex.indexer.Event.ON_DEINDEX.reference(yourTrigger)
*							unitIndex.indexer.Event.ON_DEINDEX.register(yourCode)
*
*			readonly Trigger Event.ON_DEINDEX
*				-	this is a local event that runs whenever a specific unit is deindexed
*
*				Examples:	unitIndex.indexer.Event.ON_DEINDEX.reference(yourTrigger)
*							unitIndex.indexer.Event.ON_DEINDEX.register(yourCode)
*
*			readonly static Trigger GlobalEvent.ON_DEINDEX
*				-	this is ON_DEINDEX, but global
*
*				Examples:	UnitIndexer.GlobalEvent.ON_DEINDEX.reference(yourTrigger)
*							UnitIndexer.GlobalEvent.ON_DEINDEX.register(yourCode)
*
*			readonly static UnitIndex eventIndex
*				-	when a unit is indexed or deindexed, this value stores
*					the index of that unit
*
*			readonly static unit eventUnit
*				-	when a unit is indexed or deindexed, this value stores
*					the unit
*
************************************************************************************
*
*	struct UnitIndex extends array
*
*		Fields
*		-------------------------
*
*			readonly unit unit
*				-	converts a unit index into a unit
*
*			readonly UnitIndexer indexer
*				-	the indexer in charge of handling the unit
*					useful for deindex event, which is unit specific
*
*		Operators
*		-------------------------
*
*			static method operator [] takes unit whichUnit returns UnitIndex
*				-	converts a unit into a UnitIndex
*
*		Methods
*		-------------------------
*
*			static method exists takes unit whichUnit returns boolean
*				-	determines whether the unit is indexed or not
*
*			static method isDeindexing takes unit whichUnit returns boolean
*				-	determines whether the unit is in the process of being deindexed or not
*
************************************************************************************
*
*	module GlobalUnitIndex
*
*		This has absolutely no module support
*
*		Fields
*		-------------------------
*
*			static constant boolean GLOBAL_UNIT_INDEX = true
*				-	this is used to ensure that only one unit index module is implemented.
*
*			readonly unit unit
*				-	converts a unit index into a unit
*
*			readonly boolean isUnitIndexed
*				-	is the unit index indexed
*
*			readonly UnitIndexer unitIndexer
*				-	the indexer in charge of handling the unit
*					useful for deindex event, which is unit specific
*
*		Methods
*		-------------------------
*
*			static method exists takes unit whichUnit returns boolean
*				-	determines whether the unit is indexed
*
*			static method isDeindexing takes unit whichUnit returns boolean
*				-	determines whether the unit is in the process of being deindexed or not
*
*		Interface
*		-------------------------
*
*			interface private method onUnitIndex takes nothing returns nothing
*			interface private method onUnitDeindex takes nothing returns nothing
*
*		Operators
*		-------------------------
*
*			static method operator [] takes unit whichUnit returns thistype
*				-	converts a unit into thistype
*
************************************************************************************
*
*	module UnitIndex
*
*		If you would like to create modules that work off of the UnitIndex module, implement
*		UnitIndex at the top of your module
*		
*		Fields
*		-------------------------
*
*			static constant boolean UNIT_INDEX = true
*				-	this is used to ensure that only one unit index module is implemented.
*
*			static boolean enabled
*				-	is this UnitIndex struct enabled?
*				-	this can only be disabed if onUnitIndex exists
*
*			readonly unit unit
*				-	converts a unit index into a unit
*
*			readonly boolean isUnitIndexed
*				-	is the unit index indexed for the struct?
*
*			readonly UnitIndexer unitIndexer
*				-	the indexer in charge of handling the unit
*					useful for deindex event, which is unit specific
*
*		Operators
*		-------------------------
*
*			static method operator [] takes unit whichUnit returns thistype
*				-	converts a unit into thistype
*
*		Methods
*		-------------------------
*
*			static method exists takes unit whichUnit returns boolean
*				-	determines whether the unit is indexed or not for the struct
*
*			static method isDeindexing takes unit whichUnit returns boolean
*				-	determines whether the unit is in the process of being deindexed or not
*
*		Interface
*		-------------------------
*
*			interface private method onUnitIndex takes nothing returns boolean
*				-	if return true, index the unit for this struct
*
*			interface private method onUnitDeindex takes nothing returns nothing
*				-	only runs for units indexed for this struct
*				-	if not onUnitIndex method is declared, it will run for all units
*
************************************************************************************
*
*	module UnitIndexEx
*
*		If you would like to create modules that work off of the UnitIndexEx module, implement
*		UnitIndexEx at the top of your module
*		
*		Fields
*		-------------------------
*
*			static constant boolean UNIT_INDEX_EX = true
*				-	this is used for modules that rely on local events
*					it allows these modules to differentiate between UnitIndex
*					and UnitIndexEx
*
*			static boolean enabled
*				-	is this UnitIndex struct enabled?
*				-	this can only be disabed if onUnitIndex exists
*
*			readonly unit unit
*				-	converts a unit index into a unit
*
*			readonly boolean isUnitIndexed
*				-	is the unit index indexed for the struct?
*
*			readonly UnitIndexer unitIndexer
*				-	the indexer in charge of handling the unit
*					useful for deindex event, which is unit specific
*
*			readonly static Trigger ON_INDEX
*				-	this is a local event that runs whenever any unit is indexed for the struct
*				-	this is primarily used for other resources that work off of your struct
*
*				Examples:	Struct.ON_INDEX.reference(yourTrigger)
*							Struct.ON_INDEX.register(yourCode)
*
*			readonly Trigger Event.ON_DEINDEX
*			readonly static Trigger Event.ON_DEINDEX
*				-	this is a unit specific event that runs when your local unit is deindexed
*				-	this is static if onUnitIndex does not exist
*
*				Examples:	struct.ON_DEINDEX.reference(yourTrigger)
*							struct.ON_DEINDEX.register(yourCode)
*
*		Operators
*		-------------------------
*
*			static method operator [] takes unit whichUnit returns thistype
*				-	converts a unit into thistype
*
*		Methods
*		-------------------------
*
*			static method exists takes unit whichUnit returns boolean
*				-	determines whether the unit is indexed or not for the struct
*
*			static method isDeindexing takes unit whichUnit returns boolean
*				-	determines whether the unit is in the process of being deindexed or not
*
*		Interface
*		-------------------------
*
*			interface private method onUnitIndex takes nothing returns boolean
*				-	if return true, index the unit for this struct
*
*			interface private method onUnitDeindex takes nothing returns nothing
*				-	only runs for units indexed for this struct
*				-	if not onUnitIndex method is declared, it will run for all units
*
************************************************************************************
*
*	//! textmacro CREATE_LOCAL_UNIT_INDEX
*
*		A macro was chosen because multiple modules utilizing this code may be
*		implemented into one struct. If this was a module, then all but one
*		of those modules would break.
*
*		Interface
*		-------------------------
*
*			interface private method onLocalUnitIndex takes nothing returns nothing
*				-	runs whenever a unit is indexed for this struct
*
*			interface private method onLocalUnitDeindex takes nothing returns nothing
*				-	runs whenever a unit is deindexed for this struct
*
*			interface private static method localInit takes nothing returns nothing
*				-	the macro requires the usage of onInit. Declare this method if you
*					would like onInit.
*
************************************************************************************/
	globals
		private UnitIndex p_eventIndex = 0
	endglobals

	//! runtextmacro UNIT_INDEXER_UNIT_INDEX()
	//! runtextmacro UNIT_INDEXER_PREGAME_EVENT()
	//! runtextmacro UNIT_INDEXER_UNIT_INDEXER()
	
	module GlobalUnitIndex
		static if thistype.UNIT_INDEX then
		elseif thistype.UNIT_INDEX_EX then
		else
			static constant boolean GLOBAL_UNIT_INDEX = true
			
			static method operator [] takes unit whichUnit returns thistype
				return p_UnitIndex[whichUnit]
			endmethod
			method operator unit takes nothing returns unit
				return p_UnitIndex(this).unit
			endmethod
			method operator unitIndexer takes nothing returns UnitIndexer
				return p_UnitIndex(this).indexer
			endmethod
			method operator isUnitIndexed takes nothing returns boolean
				return p_UnitIndex(this).isAllocated
			endmethod
			static method exists takes unit whichUnit returns boolean
				return p_UnitIndex.exists(whichUnit)
			endmethod
			static method isDeindexing takes unit whichUnit returns boolean
				return p_UnitIndex.isDeindexing(whichUnit)
			endmethod
			
			static if thistype.GLOBAL_UNIT_INDEX then
				static if thistype.onUnitIndex.exists then
					private static method onIndexEvent takes nothing returns boolean
						call thistype(UnitIndexer.eventIndex).onUnitIndex()
					
						return false
					endmethod
				endif
				static if thistype.onUnitDeindex.exists then
					private static method onDeindexEvent takes nothing returns boolean
						call thistype(UnitIndexer.eventIndex).onUnitDeindex()
						
						return false
					endmethod
				endif
				
				static if thistype.onUnitIndex.exists then
					private static method onInit takes nothing returns nothing
				elseif thistype.onUnitDeindex.exists then
					private static method onInit takes nothing returns nothing
				endif
				
				static if thistype.onUnitIndex.exists then
					call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onIndexEvent))
				endif
				
				static if thistype.onUnitDeindex.exists then
					call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onDeindexEvent))
				endif
				
				static if thistype.onUnitIndex.exists then
					endmethod
				elseif thistype.onUnitDeindex.exists then
					endmethod
				endif
			endif
		endif
	endmodule
	
	module UnitIndex
		static if thistype.GLOBAL_UNIT_INDEX then
			private static method error takes nothing returns nothing
				A module requires UnitIndex to operate correctly.
				This struct is currently implementing GlobalUnitIndex.
			endmethod
		elseif thistype.UNIT_INDEX_EX then
		else
			static constant boolean UNIT_INDEX = true
			
			/*
			*	[] is included because the struct automatically overrides it
			*
			*	eventIndex is included to return thistype instead of UnitIndex
			*/
			static method operator [] takes unit whichUnit returns thistype
				return UnitIndex[whichUnit]
			endmethod
			method operator unitIndexer takes nothing returns UnitIndexer
				return this
			endmethod
			method operator unit takes nothing returns unit
				return UnitIndex(this).unit
			endmethod
			
			static method isDeindexing takes unit whichUnit returns boolean
				return UnitIndex.isDeindexing(whichUnit)
			endmethod
			
			/*
			*	the method is done in the second case because when there is no
			*	onUnitIndex method, indexed depends on whether the actual
			*	instance is allocated or not
			*/
			static if thistype.onUnitIndex.exists then
				readonly boolean isUnitIndexed
			else
				method operator isUnitIndexed takes nothing returns boolean
					return p_UnitIndex(this).isAllocated
				endmethod
			endif
			
			static if thistype.onUnitIndex.exists then
				static method exists takes unit whichUnit returns boolean
					return UnitIndex.exists(whichUnit) and thistype(GetUnitUserData(whichUnit)).isUnitIndexed
				endmethod
			else
				static method exists takes unit whichUnit returns boolean
					return UnitIndex.exists(whichUnit)
				endmethod
			endif
			
			/*
			*	this is used to run local events
			*/
			static if thistype.onUnitIndex.exists then
				/*
				*	this is where UnitIndex is located
				*/
				private static TriggerCondition entryPoint
				
				/*
				*	this stores private onUnitIndex method
				*/
				private static boolexpr onIndexExpression
				
				/*
				*	enable works with code inside of entryPoint here
				*/
				private static boolean p_enabled = true
				static method operator enabled takes nothing returns boolean
					return p_enabled
				endmethod
				static method operator enabled= takes boolean enable returns nothing
					set p_enabled = enable
					
					if (enable) then
						call entryPoint.replace(onIndexExpression)
					else
						call entryPoint.replace(null)
					endif
				endmethod
			else
				/*
				*	if onUnitIndex does not exist, the struct can't be disabled
				*/
				static method operator enabled takes nothing returns boolean
					return true
				endmethod
				static method operator enabled= takes boolean enable returns nothing
					set enable = true
				endmethod
			endif
			
			/*
			*	onUnitDeindex
			*
			*	This must be implemented if onUnitIndex exists to clear isUnitIndexed
			*/
			static if thistype.onUnitDeindex.exists then
				static if thistype.onUnitIndex.exists then
					private static boolexpr onDeindexExpression
				endif
				
				private static method onDeindexEvent takes nothing returns boolean
					call thistype(UnitIndexer.eventIndex).onUnitDeindex()
					
					static if thistype.onUnitIndex.exists then
						set thistype(UnitIndexer.eventIndex).isUnitIndexed = false
					endif
					
					return false
				endmethod
			elseif thistype.onUnitIndex.exists then
				static if thistype.onUnitIndex.exists then
					private static boolexpr onDeindexExpression
				endif
				
				private static method onDeindexEvent takes nothing returns boolean
					set thistype(UnitIndexer.eventIndex).isUnitIndexed = false
					
					return false
				endmethod
			endif
			
			/*
			*	onUnitIndex
			*/
			static if thistype.onUnitIndex.exists then
				private static method onIndexEvent takes nothing returns boolean
					if (thistype(UnitIndexer.eventIndex).onUnitIndex()) then
						set thistype(UnitIndexer.eventIndex).isUnitIndexed = true
						
						/*
						*	this is always registered to clear isUnitIndexed
						*/
						call UnitIndexer(UnitIndexer.eventIndex).Event.ON_DEINDEX.register(onDeindexExpression)
					endif
					
					return false
				endmethod
			endif
			
			static if thistype.onUnitIndex.exists then
				private static method onInit takes nothing returns nothing
					set onIndexExpression = Condition(function thistype.onIndexEvent)
					set onDeindexExpression = Condition(function thistype.onDeindexEvent)
					
					set entryPoint = UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onIndexEvent))
				endmethod
			elseif thistype.onUnitDeindex.exists then
				private static method onInit takes nothing returns nothing
					call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onDeindexEvent))
				endmethod
			endif
		endif
	endmodule
	
	private struct UnitIndexList extends array
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "unitIndex2Node", "thistype")
		//! runtextmacro CREATE_TABLE_FIELD("public", "integer", "node2UnitIndex", "thistype")
		
		method add takes thistype index returns nothing
			local thistype node = enqueue()
			
			set node.node2UnitIndex = index
			set index.unitIndex2Node = node
		endmethod
		
		method delete takes nothing returns nothing
			call unitIndex2Node.remove()
		endmethod
		
		private static method init takes nothing returns nothing
			//! runtextmacro INITIALIZE_TABLE_FIELD("unitIndex2Node")
			//! runtextmacro INITIALIZE_TABLE_FIELD("node2UnitIndex")
		endmethod
		
		implement NxListT
		implement Init
	endstruct
	private struct UnitIndexModuleTrigger extends array
		method reference takes Trigger whichTrigger returns TriggerReference
			local TriggerReference triggerReference = Trigger(this).reference(whichTrigger)
			
			local UnitIndexList node = UnitIndexList(this).first
			local integer prevIndexedUnitId = p_eventIndex
			
			loop
				exitwhen node == UnitIndexList.sentinel or not whichTrigger.enabled
				
				set p_eventIndex = node.node2UnitIndex
				call whichTrigger.fire()
					
				set node = node.next
			endloop
			
			set p_eventIndex = prevIndexedUnitId
			
			return triggerReference
		endmethod
		
		method register takes boolexpr whichExpression returns TriggerCondition
			local TriggerCondition triggerCondition = Trigger(this).register(whichExpression)
			
			local trigger triggerContainer = CreateTrigger()
			
			local UnitIndexList node = UnitIndexList(this).first
			local integer prevIndexedUnitId = p_eventIndex
			
			call TriggerAddCondition(triggerContainer, whichExpression)
			
			loop
				exitwhen node == UnitIndexList.sentinel
				
				set p_eventIndex = node.node2UnitIndex
				call TriggerEvaluate(triggerContainer)
					
				set node = node.next
			endloop
			
			call TriggerClearConditions(triggerContainer)
			call DestroyTrigger(triggerContainer)
			set triggerContainer = null
			
			set p_eventIndex = prevIndexedUnitId
			
			return triggerCondition
		endmethod
	endstruct
	module UnitIndexEx
		static if thistype.GLOBAL_UNIT_INDEX then
			private static method error takes nothing returns nothing
				A module requires UnitIndexEx to operate correctly.
				This struct is currently implementing GlobalUnitIndex.
			endmethod
		elseif thistype.UNIT_INDEX then
			private static method error takes nothing returns nothing
				A module requires UnitIndexEx to operate correctly.
				This struct is currently implementing UnitIndex.
			endmethod
		else
			static constant boolean UNIT_INDEX_EX = true
			
			private static UnitIndex delegate unitIndex = 0
		
			/*
			*	[] is included because the struct automatically overrides it
			*
			*	eventIndex is included to return thistype instead of UnitIndex
			*/
			static method operator [] takes unit whichUnit returns thistype
				return UnitIndex[whichUnit]
			endmethod
			method operator unit takes nothing returns unit
				return UnitIndex(this).unit
			endmethod
			method operator unitIndexer takes nothing returns UnitIndexer
				return this
			endmethod
			
			static method isDeindexing takes unit whichUnit returns boolean
				return UnitIndex.isDeindexing(whichUnit)
			endmethod
			
			/*
			*	the method is done in the second case because when there is no
			*	onUnitIndex method, indexed depends on whether the actual
			*	instance is allocated or not
			*/
			static if thistype.onUnitIndex.exists then
				readonly boolean isUnitIndexed
			else
				method operator isUnitIndexed takes nothing returns boolean
					return p_UnitIndex(this).isAllocated
				endmethod
			endif
			
			static if thistype.onUnitIndex.exists then
				static method exists takes unit whichUnit returns boolean
					return UnitIndex.exists(whichUnit) and thistype(GetUnitUserData(whichUnit)).isUnitIndexed
				endmethod
			else
				static method exists takes unit whichUnit returns boolean
					return UnitIndex.exists(whichUnit)
				endmethod
			endif
		
			/*
			*	this is used to run local events
			*/
			static if thistype.onUnitIndex.exists then
				readonly static UnitIndexModuleTrigger ON_INDEX
			else
				readonly static WrappedTrigger ON_INDEX
			endif
			
			static if thistype.onUnitIndex.exists then
				/*
				*	this is where UnitIndex is located
				*/
				private static TriggerCondition entryPoint
				
				/*
				*	this stores private onUnitIndex method
				*/
				private static boolexpr onIndexExpression
				
				/*
				*	enable works with code inside of entryPoint here
				*/
				private static boolean p_enabled = true
				static method operator enabled takes nothing returns boolean
					return p_enabled
				endmethod
				static method operator enabled= takes boolean enable returns nothing
					set p_enabled = enable
					
					if (enable) then
						call entryPoint.replace(onIndexExpression)
					else
						call entryPoint.replace(null)
					endif
				endmethod
			else
				/*
				*	if onUnitIndex does not exist, the struct can't be disabled
				*/
				static method operator enabled takes nothing returns boolean
					return true
				endmethod
				static method operator enabled= takes boolean enable returns nothing
					set enable = true
				endmethod
			endif
			
			/*
			*	this is here so that the module runs after code that relies on the module
			*/
			static if thistype.onUnitIndex.exists then
				readonly Trigger ON_DEINDEX
			else
				readonly static Trigger ON_DEINDEX
			endif
			
			/*
			*	onUnitDeindex
			*/
			static if thistype.onUnitDeindex.exists then
				static if thistype.onUnitIndex.exists then
					private static boolexpr onDeindexExpression
				endif
				
				private static method onDeindexEvent takes nothing returns boolean
					call thistype(UnitIndexer.eventIndex).onUnitDeindex()
					
					static if thistype.onUnitIndex.exists then
						set thistype(UnitIndexer.eventIndex).isUnitIndexed = false
						
						call thistype(UnitIndexer.eventIndex).ON_DEINDEX.destroy()
						
						if (not PreGameEvent.isGameLoaded) then
							call UnitIndexList(UnitIndexer.eventIndex).delete()
						endif
					endif
					
					return false
				endmethod
			elseif thistype.onUnitIndex.exists then
				private static boolexpr onDeindexExpression
				
				private static method onDeindexEvent takes nothing returns boolean
					set thistype(UnitIndexer.eventIndex).isUnitIndexed = false
					
					call thistype(UnitIndexer.eventIndex).ON_DEINDEX.destroy()
					
					if (not PreGameEvent.isGameLoaded) then
						call UnitIndexList(UnitIndexer.eventIndex).delete()
					endif
					
					return false
				endmethod
			endif
			
			/*
			*	onUnitIndex
			*/
			static if thistype.onUnitIndex.exists then
				private static method onIndexEvent takes nothing returns boolean
					if (thistype(UnitIndexer.eventIndex).onUnitIndex()) then
						set thistype(UnitIndexer.eventIndex).isUnitIndexed = true
						
						set thistype(UnitIndexer.eventIndex).ON_DEINDEX = Trigger.create(true)
						call thistype(UnitIndexer.eventIndex).ON_DEINDEX.register(onDeindexExpression)

						call UnitIndexer(UnitIndexer.eventIndex).Event.ON_DEINDEX.reference(thistype(UnitIndexer.eventIndex).ON_DEINDEX)
						
						if (not PreGameEvent.isGameLoaded) then
							call UnitIndexList(ON_INDEX).add(UnitIndexer.eventIndex)
						endif
						
						call Trigger(thistype.ON_INDEX).fire()
					endif
					
					return false
				endmethod
			endif
			
			private static method destroyPregameUnitList takes nothing returns nothing
				call DestroyTimer(GetExpiredTimer())
				
				call UnitIndexList(ON_INDEX).destroy()
			endmethod
			
			private static method onInit takes nothing returns nothing
				set ON_INDEX = Trigger.create(false)
				
				static if thistype.onUnitIndex.exists then
					set onIndexExpression = Condition(function thistype.onIndexEvent)
					set onDeindexExpression = Condition(function thistype.onDeindexEvent)
					
					call UnitIndexList(ON_INDEX).clear()
					
					call TimerStart(CreateTimer(), 0, false, function thistype.destroyPregameUnitList)
					
					set entryPoint = UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onIndexEvent))
				else
					set ON_DEINDEX = Trigger.create(true)
					static if thistype.onUnitDeindex.exists then
						call ON_DEINDEX.register(Condition(function thistype.onDeindexEvent))
					endif
					
					call UnitIndexer.GlobalEvent.ON_DEINDEX.reference(ON_DEINDEX)
					call UnitIndexer.GlobalEvent.ON_INDEX.reference(ON_INDEX)
				endif
			endmethod
		endif
	endmodule
	
	//! textmacro CREATE_LOCAL_UNIT_INDEX
		/*
		*	There are three cases
		*
		*		Case 1: UnitIndex is implemented
		*		Case 2: UnitIndexEx is implemented
		*		Case 3: Nothing is implemented, go to Case 2
		*/
		static if thistype.UNIT_INDEX then
			/*
			*	Here, UnitIndex is implemented
			*/
			
			/*
			*	There are two cases
			*
			*		onUnitEvent exists, which means that events are conditionally local
			*		onUnitEven does not exist, meaning all events are global
			*/
			static if thistype.onUnitIndex.exists then
				/*
				*	Here, events are conditionally local
				*/
				
				static if thistype.onLocalUnitDeindex.exists then
					private static boolexpr onLocalUnitDeindexEventExpr
				endif
			
				static if thistype.onLocalUnitIndex.exists then
					/*
					*	The user has a local unit index event
					*/
					private static method onLocalUnitIndexEvent takes nothing returns boolean
						/*
						*	Here, the event is only run if the unit happened to be indexed
						*/
						if (thistype(UnitIndexer.eventIndex).isUnitIndexed) then
							static if thistype.onLocalUnitDeindex.exists then
								call UnitIndexer.eventIndex.indexer.Event.ON_DEINDEX.register(onLocalUnitDeindexEventExpr)
							endif
							
							call thistype(UnitIndexer.eventIndex).onLocalUnitIndex()
						endif
						
						return false
					endmethod
				elseif thistype.onLocalUnitDeindex.exists then
					/*
					*	The user did not declare a local unit index event
					*
					*	onLocalUnitIndexEvent is still required because the deindex events are local
					*/
					private static method onLocalUnitIndexEvent takes nothing returns boolean
						if (thistype(UnitIndexer.eventIndex).isUnitIndexed) then
							call UnitIndexer.eventIndex.indexer.Event.ON_DEINDEX.register(onLocalUnitDeindexEventExpr)
						endif
						
						return false
					endmethod
				endif
				
				static if thistype.onLocalUnitDeindex.exists then
					private static method onLocalUnitDeindexEvent takes nothing returns boolean
						call thistype(UnitIndexer.eventIndex).onLocalUnitDeindex()
						return false
					endmethod
				endif
				
				/*
				*	onLocalUnitDeindexEvent is not registered globally here because these are local
				*	events. It must be created inside of onLocalUnitIndexEvent whether or not
				*	onLocalUnitIndex exists.
				*/
				static if thistype.onLocalUnitIndex.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onLocalUnitDeindex.exists then
							set onLocalUnitDeindexEventExpr = Condition(function thistype.onLocalUnitDeindexEvent)
						endif
						
						call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onLocalUnitIndexEvent))
						
						static if thistype.localInit.exists then
							call localInit()
						endif
					endmethod
				elseif thistype.onLocalUnitDeindex.exists then
					private static method onInit takes nothing returns nothing
						set onLocalUnitDeindexEventExpr = Condition(function thistype.onLocalUnitDeindexEvent)
							
						call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onLocalUnitIndexEvent))
						
						static if thistype.localInit.exists then
							call localInit()
						endif
					endmethod
				endif
			else
				/*
				*	Here, all events are global
				*/
				static if thistype.onLocalUnitIndex.exists then
					private static method onLocalUnitIndexEvent takes nothing returns boolean
						call thistype(UnitIndexer.eventIndex).onLocalUnitIndex()
						return false
					endmethod
				endif
				
				static if thistype.onLocalUnitDeindex.exists then
					private static method onLocalUnitDeindexEvent takes nothing returns boolean
						call thistype(UnitIndexer.eventIndex).onLocalUnitDeindex()
						return false
					endmethod
				endif
				
				static if thistype.onLocalUnitIndex.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onLocalUnitDeindex.exists then
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onLocalUnitDeindexEvent))
						endif
						
						call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onLocalUnitIndexEvent))
						
						static if thistype.localInit.exists then
							call localInit()
						endif
					endmethod
				elseif thistype.onLocalUnitDeindex.exists then
					private static method onInit takes nothing returns nothing
						call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onLocalUnitDeindexEvent))
						
						static if thistype.localInit.exists then
							call localInit()
						endif
					endmethod
				endif
			endif
		elseif thistype.GLOBAL_UNIT_INDEX then
			private static method error takes nothing returns nothing
				A module requires either UnitIndex or UnitIndexEx to operate correctly.
				This struct is currently implementing GlobalUnitIndex.
			endmethod
		else
			/*
			*	Here, UnitIndexEx is either implemented or nothing is implemented
			*
			*	Implement UnitIndexEx and work with its local events
			*/
			implement UnitIndexEx
			
			static if thistype.onUnitIndex.exists then
				/*
				*	local events
				*/
				static if thistype.onLocalUnitDeindex.exists then
					private static boolexpr onLocalUnitDeindexEventExpr
				endif
				
				/*
				*	if onUnitIndex exists, then onLocalUnitDeindex is local
				*
				*	this means that if onLocalUnitDeindex exists, the onLocalUnitIndexEvent must be
				*	made so that it can register onLocalUnitDeindex locally
				*/
				static if thistype.onLocalUnitIndex.exists then
					private static method onLocalUnitIndexEvent takes nothing returns boolean
						static if thistype.onLocalUnitDeindex.exists then
							call thistype(UnitIndexer.eventIndex).ON_DEINDEX.register(onLocalUnitDeindexEventExpr)
						endif
						
						call thistype(UnitIndexer.eventIndex).onLocalUnitIndex()
						
						return false
					endmethod
				elseif thistype.onLocalUnitDeindex.exists then
					private static method onLocalUnitIndexEvent takes nothing returns boolean
						call thistype(UnitIndexer.eventIndex).ON_DEINDEX.register(onLocalUnitDeindexEventExpr)
							
						return false
					endmethod
				endif
			elseif thistype.onLocalUnitIndex.exists then
				/*
				*	global events
				*
				*		onLocalUnitDeindex is run globally, so it doesn't need onLocalUnitIndexEvent
				*		anymore
				*/
				private static method onLocalUnitIndexEvent takes nothing returns boolean
					call thistype(UnitIndexer.eventIndex).onLocalUnitIndex()
					
					return false
				endmethod
			endif
			
			static if thistype.onLocalUnitDeindex.exists then
				private static method onLocalUnitDeindexEvent takes nothing returns boolean
					call thistype(UnitIndexer.eventIndex).onLocalUnitDeindex()
					
					return false
				endmethod
			endif
			
			/*
			*	The reason why ON_INDEX is used is so that the module can be enabled/disabled
			*	correctly
			*/
			private static method onInit takes nothing returns nothing
				static if thistype.onUnitIndex.exists then
					/*
					*	local events
					*/
					static if thistype.onLocalUnitDeindex.exists then
						set onLocalUnitDeindexEventExpr = Condition(function thistype.onLocalUnitDeindexEvent)
					endif
					
					/*
					*	onLocalUnitIndexEvent is registered for onLocalUnitdeindex because onLocalUnitDeindex
					*	must be registered to each unit. This means that it must register as units are indexed.
					*/
					static if thistype.onLocalUnitIndex.exists then
						call thistype.ON_INDEX.register(Condition(function thistype.onLocalUnitIndexEvent))
					elseif thistype.onLocalUnitDeindex.exists then
						call thistype.ON_INDEX.register(Condition(function thistype.onLocalUnitIndexEvent))
					endif
				else
					/*
					*	global events
					*
					*	ON_DEINDEX is used here instead of UnitIndexer.GlobalEvent.ON_DEINDEX for proper
					*	execution order
					*/
					
					static if thistype.onLocalUnitDeindex.exists then
						call thistype.ON_DEINDEX.register(Condition(function thistype.onLocalUnitDeindexEvent))
					endif
					
					static if thistype.onLocalUnitIndex.exists then
						call thistype.ON_INDEX.register(Condition(function thistype.onLocalUnitIndexEvent))
					endif
				endif
				
				static if thistype.localInit.exists then
					call localInit()
				endif
			endmethod
		endif
	//! endtextmacro
endlibrary//===========================================================================
// Trigger: UnitIndexer UnitIndex
//===========================================================================
/*
*	requires
*
*		Alloc
*		ErrorMessage
*
*		private struct p_UnitIndex extends array
*
*		method operator isAllocated takes nothing returns boolean
*		debug static method calculateMemoryUsage takes nothing returns integer
*		debug static method getAllocatedMemoryAsString takes nothing returns string
*
*		method operator indexer takes nothing returns UnitIndexer
*		method operator unit takes nothing returns unit
*		static method operator [] takes unit whichUnit returns thistype
*		static method exists takes unit whichUnit returns boolean
*
*	struct UnitIndex extends array
*
*		readonly unit unit
*		readonly UnitIndexer indexer
*
*		static method operator [] takes unit whichUnit returns UnitIndex
*
*		static method exists takes unit whichUnit returns boolean
*		static method isDeindexing takes unit whichUnit returns boolean
*/

//! textmacro UNIT_INDEXER_UNIT_INDEX
private struct p_UnitIndex extends array
	implement AllocQ

	private unit p_unit
	
	static method create takes unit whichUnit returns thistype
		local thistype this = allocate()
		
		set p_unit = whichUnit
		call SetUnitUserData(whichUnit, this)

		call UnitAddAbility(whichUnit, ABILITIES_UNIT_INDEXER)
		call UnitMakeAbilityPermanent(whichUnit, true, ABILITIES_UNIT_INDEXER)
		
		return this
	endmethod
	
	method destroy takes nothing returns nothing
		set p_unit = null
	
		call deallocate()
	endmethod
	
	method operator indexer takes nothing returns UnitIndexer
		debug call ThrowWarning(not isAllocated,											"UnitIndexer", "indexer", "thistype", this, "Getting indexer from a deallocated unit index.")
		
		return this
	endmethod
	
	method operator unit takes nothing returns unit
		debug call ThrowWarning(not isAllocated,											"UnitIndexer", "unit", "thistype", this, "Getting unit from a deallocated unit index.")
	
		return p_unit
	endmethod
	static method operator [] takes unit whichUnit returns thistype
		debug call ThrowWarning(GetUnitTypeId(whichUnit) == 0,								"UnitIndexer", "[]", "thistype", 0, "Getting unit index of a null unit.")
		debug call ThrowWarning(thistype(GetUnitUserData(whichUnit)).p_unit != whichUnit,	"UnitIndexer", "[]", "thistype", 0, "Getting unit index of a unit that isn't indexed.")
		
		return GetUnitUserData(whichUnit)
	endmethod
	
	static method exists takes unit whichUnit returns boolean
		debug call ThrowWarning(GetUnitTypeId(whichUnit) == 0, "UnitIndexer", "exists",		"thistype", 0, "Checking for the existence of a null unit.")
	
		return thistype(GetUnitUserData(whichUnit)).p_unit == whichUnit
	endmethod
	
	static method isDeindexing takes unit whichUnit returns boolean
		return GetUnitTypeId(whichUnit) != 0 and GetUnitAbilityLevel(whichUnit, ABILITIES_UNIT_INDEXER) == 0 and thistype(GetUnitUserData(whichUnit)).p_unit == whichUnit
	endmethod
endstruct

struct UnitIndex extends array
	method operator unit takes nothing returns unit
		return p_UnitIndex(this).unit
	endmethod
	
	static method operator [] takes unit whichUnit returns thistype
		return p_UnitIndex[whichUnit]
	endmethod
	
	static method exists takes unit whichUnit returns boolean
		return p_UnitIndex.exists(whichUnit)
	endmethod
	
	static method isDeindexing takes unit whichUnit returns boolean
		return p_UnitIndex.isDeindexing(whichUnit)
	endmethod
	
	method operator indexer takes nothing returns UnitIndexer
		return p_UnitIndex(this).indexer
	endmethod
endstruct
//! endtextmacro//===========================================================================
// Trigger: UnitIndexer UnitIndexer
//===========================================================================
/*
*	requires
*
*		Event
*		WorldBounds
*
*	struct UnitIndexer extends array
*
*		static boolean enabled = true
*
*		readonly static Trigger GlobalEvent.ON_INDEX
*		readonly static Trigger GlobalEvent.ON_DEINDEX
*		readonly Trigger Event.ON_DEINDEX
*
*		readonly UnitIndex eventIndex = 0
*		readonly unit eventUnit = null
*
*	private struct WrappedTrigger extends array
*
*		method reference takes Trigger whichTrigger returns nothing
*
*		method register takes boolexpr whichExpression returns nothing
*
*/

//! textmacro UNIT_INDEXER_UNIT_INDEXER
private struct WrappedTrigger extends array
	static if DEBUG_MODE then
		method reference takes Trigger whichTrigger returns TriggerReference
			return reference_p(whichTrigger)
		endmethod
		
		method register takes boolexpr whichExpression returns TriggerCondition
			return register_p(whichExpression)
		endmethod
		
		private method reference_p takes Trigger whichTrigger returns TriggerReference
			local TriggerReference triggerReference = Trigger(this).reference(whichTrigger)
			
			call PreGameEvent.fireTrigger(whichTrigger)
			
			return triggerReference
		endmethod
	
		private method register_p takes boolexpr whichExpression returns TriggerCondition
			local TriggerCondition triggerCondition = Trigger(this).register(whichExpression)
			
			call PreGameEvent.fireExpression(whichExpression)
			
			return triggerCondition
		endmethod
	else
		method reference takes Trigger whichTrigger returns TriggerReference
			local TriggerReference triggerReference = Trigger(this).reference(whichTrigger)
			
			call PreGameEvent.fireTrigger(whichTrigger)
			
			return triggerReference
		endmethod
	
		method register takes boolexpr whichExpression returns TriggerCondition
			local TriggerCondition triggerCondition = Trigger(this).register(whichExpression)
			
			call PreGameEvent.fireExpression(whichExpression)
			
			return triggerCondition
		endmethod
	endif
endstruct

private struct UnitIndexerTriggerGlobal extends array
	readonly static WrappedTrigger	ON_INDEX
	readonly static Trigger			ON_DEINDEX
	
	private static method init takes nothing returns nothing
		set ON_INDEX = Trigger.create(false)
		set ON_DEINDEX = Trigger.create(true)
	endmethod
	
	implement Init
endstruct

private keyword ON_DEINDEX_MAIN
private struct UnitIndexerTrigger extends array
	readonly Trigger ON_DEINDEX
	
	method createDeindex takes nothing returns nothing
		set ON_DEINDEX = Trigger.create(true)
		
		call ON_DEINDEX.reference(UnitIndexerTriggerGlobal.ON_DEINDEX)
	endmethod
	
	method destroyDeindex takes nothing returns nothing
		call ON_DEINDEX.destroy()
	endmethod
endstruct

struct UnitIndexer extends array
	private trigger deindexTrigger
	private static boolexpr onDeindexCondition

	static method operator eventIndex takes nothing returns UnitIndex
		return p_eventIndex
	endmethod
	static method operator eventUnit takes nothing returns unit
		return eventIndex.unit
	endmethod
	
	static method operator GlobalEvent takes nothing returns UnitIndexerTriggerGlobal
		return 0
	endmethod
	method operator Event takes nothing returns UnitIndexerTrigger
		return this
	endmethod

	static boolean enabled = true
	
	private static method fire takes Trigger whichTrigger, integer whichIndex returns nothing
		local integer prevIndexedUnit = p_eventIndex
		set p_eventIndex = whichIndex
		call whichTrigger.fire()
		set p_eventIndex = prevIndexedUnit
	endmethod
	
	private static method onIndex takes nothing returns boolean
		local unit indexedUnit = GetFilterUnit()
		local p_UnitIndex index
		
		if (enabled and not p_UnitIndex.exists(indexedUnit)) then
			set index = p_UnitIndex.create(indexedUnit)
			
			set thistype(index).deindexTrigger = CreateTrigger()
			call TriggerRegisterUnitEvent(thistype(index).deindexTrigger, indexedUnit, EVENT_UNIT_ISSUED_ORDER)
			call TriggerAddCondition(thistype(index).deindexTrigger, onDeindexCondition)
			
			call PreGameEvent.addUnitIndex(index)
			
			call thistype(index).Event.createDeindex()
			
			call fire(GlobalEvent.ON_INDEX, index)
		endif
		
		set indexedUnit = null
		
		return false
	endmethod
	
	private static method onDeindex takes nothing returns boolean
		local p_UnitIndex index = GetUnitUserData(GetTriggerUnit())
		
		if (GetUnitAbilityLevel(GetTriggerUnit(), ABILITIES_UNIT_INDEXER) == 0) then
			call PreGameEvent.removeUnitIndex(index)
			
			call fire(thistype(index).Event.ON_DEINDEX, index)
			
			call thistype(index).Event.destroyDeindex()
			
			call DestroyTrigger(thistype(index).deindexTrigger)
			set thistype(index).deindexTrigger = null
			
			call index.destroy()
		endif
		
		return false
	endmethod
	
	private static method init takes nothing returns nothing
		local trigger indexTrigger = CreateTrigger()
		
		local boolexpr onIndexCondition	 = Condition(function thistype.onIndex)
		
		local group enumGroup = CreateGroup()
		
		local integer currentPlayerId = 15
		local player currentPlayer
		
		set onDeindexCondition= Condition(function thistype.onDeindex)
		
		call TriggerRegisterEnterRegion(indexTrigger, WorldBounds.worldRegion, onIndexCondition)
		
		loop
			set currentPlayer = Player(currentPlayerId)
			
			call SetPlayerAbilityAvailable(currentPlayer, ABILITIES_UNIT_INDEXER, false)
			call GroupEnumUnitsOfPlayer(enumGroup, currentPlayer, onIndexCondition)
			
			exitwhen currentPlayerId == 0
			set currentPlayerId = currentPlayerId - 1
		endloop
		
		call DestroyGroup(enumGroup)
		
		set onIndexCondition = null
		
		set enumGroup = null
		set currentPlayer = null
		
		set indexTrigger = null
	endmethod
	
	implement Init
endstruct
//! endtextmacro//===========================================================================
// Trigger: UnitIndexer Pregame Event
//===========================================================================
/*
*	requires
*
*		ListNx
*
*	private struct PreGameEvent extends array
*
*		Evaluates all triggers and functions registered to
*		Unit Indexer before game start for all indexed units.
*
*
*		static method fireTrigger takes trigger whichTrigger returns nothing
*		static method fireExpression takes boolexpr whichExpression returns nothing
*
*		static method addUnitIndex takes integer whichUnitIndex returns nothing
*		static method removeUnitIndex takes integer whichUnitIndex returns nothing
*/

//! textmacro UNIT_INDEXER_PREGAME_EVENT
private struct PreGameEvent extends array
	readonly static boolean isGameLoaded = false

	implement ListNx
	
	private static method p_fireTrigger takes Trigger whichTrigger returns nothing
		local thistype this = first
		local integer prevIndexedUnitId = p_eventIndex
		
		loop
			exitwhen this == sentinel or not whichTrigger.enabled
			
			set p_eventIndex = this
			call whichTrigger.fire()
			
			set this = next
		endloop
		
		set p_eventIndex = prevIndexedUnitId
	endmethod
	static method fireTrigger takes Trigger whichTrigger returns nothing
		if (first != 0) then
			call p_fireTrigger(whichTrigger)
		endif
	endmethod
	
	private static method p_fireExpression takes boolexpr whichExpression returns nothing
		local trigger triggerContainer = CreateTrigger()
		local thistype this = first
		local integer prevIndexedUnitId = p_eventIndex
		
		call TriggerAddCondition(triggerContainer, whichExpression)
		
		loop
			exitwhen this == sentinel
			
			set p_eventIndex = this
			call TriggerEvaluate(triggerContainer)
			
			set this = next
		endloop
		
		call TriggerClearConditions(triggerContainer)
		call DestroyTrigger(triggerContainer)
		set triggerContainer = null
		
		set p_eventIndex = prevIndexedUnitId
	endmethod
	static method fireExpression takes boolexpr whichExpression returns nothing
		if (first != 0) then
			call p_fireExpression(whichExpression)
		endif
	endmethod
	
	static method addUnitIndex takes integer whichUnitIndex returns nothing
		if (isGameLoaded) then
			return
		endif
		
		call enqueue(whichUnitIndex)
	endmethod
	
	static method removeUnitIndex takes integer whichUnitIndex returns nothing
		if (isGameLoaded) then
			return
		endif
		
		call thistype(whichUnitIndex).remove()
	endmethod
	
	private static method run takes nothing returns nothing
		call DestroyTimer(GetExpiredTimer())
		
		set isGameLoaded = true
		
		call clear()
	endmethod
	private static method init takes nothing returns nothing
		call TimerStart(CreateTimer(), 0, false, function thistype.run)
	endmethod
	
	implement Init
endstruct
//! endtextmacro//===========================================================================
// Trigger: DDS
//===========================================================================
library DDS /* v2.0.0.0
*************************************************************************************
*
*	*/	uses	/*
*
*		*/	TriggerRefresh	/*
*		*/	Init			/*
*
************************************************************************************
*
*   SETTINGS
*/
globals
	/*************************************************************************************
	*
	*   How many units can refresh at a given moment (when a trigger is rebuilt).
	*   larger size means less triggers but harder refreshes.
	*
	*************************************************************************************/
	private constant integer TRIGGER_SIZE = 80
endglobals
/*
*************************************************************************************
*
*	struct DDS extends array
*
*	module DDS
*
*		boolean enabled
*			-	enables and disables the system for a given unit
*
*			Examples:	DDS[unit index].enabled = true			
*
*************************************************************************************/
	private keyword RefreshTrigger

	/*
	*	DamageEvent
	*/
	private keyword DAMAGE_EVENT_API	
	private keyword DAMAGE_EVENT_RESPONSE_LOCALS
	private keyword DAMAGE_EVENT_RESPONSE_BEFORE
	private keyword DAMAGE_EVENT_RESPONSE
	private keyword DAMAGE_EVENT_RESPONSE_AFTER
	private keyword DAMAGE_EVENT_RESPONSE_CLEANUP
	private keyword DAMAGE_EVENT_INTERFACE
	private keyword DAMAGE_EVENT_INIT
	
	/*
	*	DamageEventModification
	*/
	private keyword DAMAGE_EVENT_MODIFICATION_API
	private keyword DAMAGE_EVENT_MODIFICATION_RESPONSE_LOCALS
	private keyword DAMAGE_EVENT_MODIFICATION_RESPONSE_BEFORE
	private keyword DAMAGE_EVENT_MODIFICATION_RESPONSE
	private keyword DAMAGE_EVENT_MODIFICATION_RESPONSE_AFTER
	private keyword DAMAGE_EVENT_MODIFICATION_RESPONSE_CLEANUP
	private keyword DAMAGE_EVENT_MODIFICATION_INTERFACE
	private keyword DAMAGE_EVENT_MODIFICATION_INIT
	
	/*
	*	DamageEventArchetype
	*/
	private keyword DAMAGE_EVENT_ARCHETYPE_API
	private keyword DAMAGE_EVENT_ARCHETYPE_RESPONSE_LOCALS
	private keyword DAMAGE_EVENT_ARCHETYPE_RESPONSE_BEFORE
	private keyword DAMAGE_EVENT_ARCHETYPE_RESPONSE
	private keyword DAMAGE_EVENT_ARCHETYPE_RESPONSE_AFTER
	private keyword DAMAGE_EVENT_ARCHETYPE_RESPONSE_CLEANUP
	private keyword DAMAGE_EVENT_ARCHETYPE_INTERFACE
	private keyword DAMAGE_EVENT_ARCHETYPE_INIT

	//! runtextmacro optional DAMAGE_EVENT_CODE()
	//! runtextmacro optional DAMAGE_EVENT_MODIFICATION_CODE()
	//! runtextmacro optional DAMAGE_EVENT_ARCHETYPE_CODE()
	
	private keyword DDS_onDamage
	struct DDS extends array
		method operator enabled takes nothing returns boolean
			return IsTriggerEnabled(RefreshTrigger(this).parent.trigger)
		endmethod
		static if not ENABLED_EXISTS then
			method operator enabled= takes boolean b returns nothing
				if (b) then
					call EnableTrigger(RefreshTrigger(this).parent.trigger)
				else
					call DisableTrigger(RefreshTrigger(this).parent.trigger)
				endif
			endmethod
		else
			implement optional DAMAGE_EVENT_ENABLE
		endif
	
		implement optional DAMAGE_EVENT_API
		implement optional DAMAGE_EVENT_MODIFICATION_API
		implement optional DAMAGE_EVENT_ARCHETYPE_API
	
		static method DDS_onDamage takes nothing returns nothing
			implement optional DAMAGE_EVENT_RESPONSE_LOCALS
			implement optional DAMAGE_EVENT_MODIFICATION_RESPONSE_LOCALS
			implement optional DAMAGE_EVENT_ARCHETYPE_RESPONSE_LOCALS
			
			implement optional DAMAGE_EVENT_RESPONSE_BEFORE
			implement optional DAMAGE_EVENT_MODIFICATION_RESPONSE_BEFORE
			implement optional DAMAGE_EVENT_ARCHETYPE_RESPONSE_BEFORE
			
			implement optional DAMAGE_EVENT_RESPONSE
			implement optional DAMAGE_EVENT_MODIFICATION_RESPONSE
			implement optional DAMAGE_EVENT_ARCHETYPE_RESPONSE
			
			implement optional DAMAGE_EVENT_RESPONSE_AFTER
			implement optional DAMAGE_EVENT_MODIFICATION_RESPONSE_AFTER
			implement optional DAMAGE_EVENT_ARCHETYPE_RESPONSE_AFTER
			
			implement optional DAMAGE_EVENT_RESPONSE_CLEANUP
			implement optional DAMAGE_EVENT_MODIFICATION_RESPONSE_CLEANUP
			implement optional DAMAGE_EVENT_ARCHETYPE_RESPONSE_CLEANUP
		endmethod
	endstruct
	
	module DDS
		private static delegate DDS dds = 0
		
		implement optional DAMAGE_EVENT_INTERFACE
		implement optional DAMAGE_EVENT_MODIFICATION_INTERFACE
		implement optional DAMAGE_EVENT_ARCHETYPE_INTERFACE
	endmodule

	//! runtextmacro TRIGGER_REFRESH("TRIGGER_SIZE", "EVENT_UNIT_DAMAGED", "function DDS.DDS_onDamage")
	
	private struct DDS_Init extends array
		private static method init takes nothing returns nothing
			implement optional DAMAGE_EVENT_INIT
			implement optional DAMAGE_EVENT_MODIFICATION_INIT
			implement optional DAMAGE_EVENT_ARCHETYPE_INIT
		endmethod
	
		implement Init
	endstruct
endlibrary//===========================================================================
// Trigger: Damage Event DDS Plugin
//===========================================================================
library DamageEvent /* v2.0.0.0
*************************************************************************************
*
*   Damage Event plugin for DDS
*
*************************************************************************************
*
*   */uses/*
*
*       */ DDS                      /*
*		*/ Trigger					/*
*
************************************************************************************
*
*   SETTINGS
*/
globals
	/*************************************************************************************
	*
	*   Enabling four phases, which splits ON_DAMAGE into ON_DAMAGE and ON_DAMAGE_OUTGOING
	*
	*	This adds a little overhead, but gives more functionality. Only enable these extra
	*	phases if you need them.
	*
	*************************************************************************************/
	public constant boolean FOUR_PHASE = true
endglobals
/*
*************************************************************************************
*
*   API
*
*       readonly static Trigger DDS.GlobalDamageEvent.ON_DAMAGE_BEFORE
*			-	runs first whenever any unit is damaged (setup)
*
*		readonly static Trigger DDS.GlobalDamageEvent.ON_DAMAGE_AFTER
*			-	runs last and in reverse whenever any unit is damaged (cleanup)
*
*		readonly Trigger DDS.ON_DAMAGE
*			-	runs when a specific unit is damaged
*
*		method fireLocal takes nothing returns nothing
*			-	fires ON_DAMAGE followed by ON_DAMAGE_AFTER correctly
*
*			-	this is used for custom combat systems, meaning that the DDS data for
*				damage, target, etc will no longer be accurate
*
*			-	it is expected that damage data is created (similarly to ON_DAMAGE_BEFORE)
*
*       readony static real damage
*           -   amount of damage dealt
*
*       readonly static unit target
*       readonly static UnitIndex targetId
*           -   damaged unit
*
*       readonly static unit source
*       readonly static UnitIndex sourceId
*           -   unit that dealt damage
*
*       readonly static player sourcePlayer
*           -   owner of source
*
*		readonly static player targetPlayer
*			-	owner of target
*
*
*		MUST BE DECLARED -		onDamageBefore
*		------------------------------------------
*
*			readonly static Trigger ON_DAMAGE_BEFORE
*				-	allows a user to run through the struct rather than DDS
*
*
*		MUST BE DECLARED -		onDamageAfter
*		------------------------------------------
*
*			readonly static Trigger ON_DAMAGE_AFTER
*				-	allows a user to run through the struct rather than DDS
*
*
*		MUST BE DECLARED -		onDamage
*		------------------------------------------
*
*			readonly Trigger ON_DAMAGE
*				-	allows a user to run through the struct rather than DDS
*
*			method enableDamageEventLocal takes nothing returns boolean
*				-	will enable the local event for a given unit index
*					after the first enable, it will just increase a counter
*
*				-	returns true when actually enabling
*					returns false when just increasing the counter
*
*					Examples:	local MyStruct modifier = someUnitIndex //on item pickup
*								call modifier.enableDamageEventLocal()
*								set modifier.physicalDamageReduction = modifier.physicalDamageReduction + item.physicalDamageReduction
*
*			method disableDamageEventLocal takes nothing returns boolean
*				-	will disable the local event for a given unit index
*					decreases a counter until that counter reaches 0, at which point
*					the thing is actuall disabled
*
*				-	returns true when actually disabling
*					returns false when just decreasing the counter
*
*					Examples:	local MyStruct modifier = someUnitIndex //on item drop
*								call modifier.disableDamageEventLocal()
*								set modifier.physicalDamageReduction = modifier.physicalDamageReduction - item.physicalDamageReduction
*
*	FOUR_PHASE ONLY SECTION
*
*		readonly Trigger DDS.ON_DAMAGE_OUTGOING
*			-	runs when a specific unit deals damage
*
*		MUST BE DECLARED -		onDamageOutgoing
*		------------------------------------------
*
*			readonly Trigger ON_DAMAGE_OUTGOING
*				-	allows a user to run through the struct rather than DDS
*
*			method enableDamageEventLocalOutgoing takes nothing returns boolean
*				-	will enable the local event for a given unit index
*					after the first enable, it will just increase a counter
*
*				-	returns true when actually enabling
*					returns false when just increasing the counter
*
*					Examples:	local MyStruct modifier = someUnitIndex //on item pickup
*								call modifier.enableDamageEventLocalOutgoing()
*								set modifier.attackIncrease = modifier.attackIncrease + item.attackIncrease
*
*			method disableDamageEventLocalOutgoing takes nothing returns boolean
*				-	will disable the local event for a given unit index
*					decreases a counter until that counter reaches 0, at which point
*					the thing is actuall disabled
*
*				-	returns true when actually disabling
*					returns false when just decreasing the counter
*
*					Examples:	local MyStruct modifier = someUnitIndex //on item drop
*								call modifier.disableDamageEventLocalOutgoing()
*								set modifier.attackIncrease = modifier.attackIncrease - item.attackIncrease
*
*************************************************************************************
*
*   Interface
*
*       (optional) private static method onDamageBefore takes nothing returns nothing
*           -   is run first whenever a unit is damaged
*       (optional) private static method onDamageAfter takes nothing returns nothing
*           -   is run last whenever a unit is damaged
*
*       (optional) private method onDamage takes nothing returns nothing
*           -   is run when a specific unit is damaged
*
*			-	this == index of unit taking damage
*
*	FOUR_PHASE ONLY SECTION
*
*       (optional) private method onDamageOutgoing takes nothing returns nothing
*           -   is run when a specific unit deals damage
*
*			-	this == index of unit dealing damage
*
*************************************************************************************
*
*   Plugin Information (can only be used by other plugins)
*
*       static UnitIndex targetId_p
*       static UnitIndex sourceId_p
*
*       static real damage_p
*
*       static player sourcePlayer_p
*       static player targetPlayer_p
*
*************************************************************************************/
    //! textmacro DAMAGE_EVENT_CODE
	
    private keyword damage_p
    private keyword targetId_p
    private keyword sourceId_p
    private keyword sourcePlayer_p
    private keyword targetPlayer_p
	
    scope DamageEvent
		private keyword init
		private keyword ON_DAMAGE_MAIN
		private keyword ON_DAMAGE_MAIN_2
		
		private struct GlobalDamageEvent extends array
			readonly static Trigger ON_DAMAGE_BEFORE
			readonly static Trigger ON_DAMAGE_AFTER
			
			static method init takes nothing returns nothing
				set ON_DAMAGE_BEFORE = Trigger.create(false)
				set ON_DAMAGE_AFTER = Trigger.create(true)
			endmethod
		endstruct
		struct LocalDamageEvent extends array
			readonly Trigger ON_DAMAGE_MAIN				//BEFORE, OUTGOING
			readonly Trigger ON_DAMAGE_MAIN_2			//INCOMING, AFTER
			readonly Trigger ON_DAMAGE
			
			method fireLocal takes nothing returns nothing
				call ON_DAMAGE_MAIN_2.fire()
			endmethod
		
			static if DamageEvent_FOUR_PHASE then
				readonly Trigger ON_DAMAGE_OUTGOING
				
				private static method onUnitIndex takes nothing returns boolean
					local thistype this = UnitIndexer.eventIndex
					
					set ON_DAMAGE_MAIN = Trigger.create(false)
					set ON_DAMAGE_MAIN_2 = Trigger.create(false)
					set ON_DAMAGE = Trigger.create(false)
					set ON_DAMAGE_OUTGOING = Trigger.create(false)
					
					call ON_DAMAGE_MAIN.reference(GlobalDamageEvent.ON_DAMAGE_BEFORE)
					call ON_DAMAGE_MAIN.reference(ON_DAMAGE_OUTGOING)
					call ON_DAMAGE_MAIN_2.reference(ON_DAMAGE)
					call ON_DAMAGE_MAIN_2.reference(GlobalDamageEvent.ON_DAMAGE_AFTER)
			
					return false
				endmethod
				
				private static method onUnitDeindex takes nothing returns boolean
					local thistype this = UnitIndexer.eventIndex
					
					call ON_DAMAGE_MAIN.destroy()
					call ON_DAMAGE_MAIN_2.destroy()
					call ON_DAMAGE.destroy()
					call ON_DAMAGE_OUTGOING.destroy()
				
					return false
				endmethod
			else
				private static method onUnitIndex takes nothing returns boolean
					local thistype this = UnitIndexer.eventIndex
					
					set ON_DAMAGE_MAIN = Trigger.create(false)
					set ON_DAMAGE_MAIN_2 = Trigger.create(false)
					set ON_DAMAGE = Trigger.create(false)
					
					call ON_DAMAGE_MAIN.reference(GlobalDamageEvent.ON_DAMAGE_BEFORE)
					call ON_DAMAGE_MAIN.reference(ON_DAMAGE_MAIN_2)
					call ON_DAMAGE_MAIN_2.reference(ON_DAMAGE)
					call ON_DAMAGE_MAIN_2.reference(GlobalDamageEvent.ON_DAMAGE_AFTER)
			
					return false
				endmethod
				
				private static method onUnitDeindex takes nothing returns boolean
					local thistype this = UnitIndexer.eventIndex
					
					call ON_DAMAGE_MAIN.destroy()
					call ON_DAMAGE_MAIN_2.destroy()
					call ON_DAMAGE.destroy()
				
					return false
				endmethod
			endif
			
			static method init takes nothing returns nothing
				call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
				call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
			endmethod
		endstruct
		
        /*
        *   DDS API
        *
        *       DDS.GlobalEvent.ON_DAMAGE_BEFORE
        *       DDS.GlobalEvent.ON_DAMAGE_AFTER
		*		DDS.Event.ON_DAMAGE
		*
        *       DDS.target
		*		DDS.targetId
        *       DDS.source
		*		DDS.sourceId
		*		DDS.sourcePlayer
        *       DDS.damage
        *
        */
        private keyword damageEventInit
        
        module DAMAGE_EVENT_API
			static method operator GlobalEvent takes nothing returns GlobalDamageEvent
				return 0
			endmethod
			method operator Event takes nothing returns LocalDamageEvent
				return this
			endmethod
		
            static UnitIndex targetId_p = 0
            static UnitIndex sourceId_p = 0
            static real damage_p = 0
            static player sourcePlayer_p = null
			static player targetPlayer_p = null
            
            static method operator targetId takes nothing returns UnitIndex
                return targetId_p
            endmethod
            static method operator target takes nothing returns unit
                return targetId.unit
            endmethod
            
            static method operator sourceId takes nothing returns UnitIndex
                return sourceId_p
            endmethod
            static method operator source takes nothing returns unit
                return sourceId.unit
            endmethod
            
            static method operator damage takes nothing returns real
                return damage_p
            endmethod
            
            static method operator sourcePlayer takes nothing returns player
                return sourcePlayer_p
            endmethod
			
            static method operator targetPlayer takes nothing returns player
                return targetPlayer_p
            endmethod
			
			static method damageEventInit takes nothing returns nothing
				call GlobalDamageEvent.init()
				call LocalDamageEvent.init()
			endmethod
        endmodule
		
        module DAMAGE_EVENT_INIT
            call DDS.damageEventInit()
        endmodule

        /*
        *   DDS Interface
        *
        *       interface private static method onDamage takes nothing returns nothing
        *
        *       
        */
        module DAMAGE_EVENT_INTERFACE
			/*
			*	private static method getCondition takes code c returns boolexpr
			*/
			static if thistype.onDamageBefore.exists then
				private static method getCondition takes code c returns boolexpr
					return Condition(c)
					return null
				endmethod
			elseif thistype.onDamageAfter.exists then
				private static method getCondition takes code c returns boolexpr
					return Condition(c)
					return null
				endmethod
			endif
			
			static if thistype.onDamageBefore.exists then
				readonly static Trigger ON_DAMAGE_BEFORE
			endif
			static if thistype.onDamageAfter.exists then
				readonly static Trigger ON_DAMAGE_AFTER
			endif
			
			static if thistype.onDamage.exists then
				readonly Trigger ON_DAMAGE
				private static boolexpr onDamageExpr
				private TriggerReference ON_DAMAGE_REF
				
				private static method onDamageFunc takes nothing returns boolean
					call thistype(targetId).onDamage()
					return false
				endmethod
				
				private integer count
				
				method enableDamageEventLocal takes nothing returns boolean
					set count = count + 1
				
					if (count == 1) then
						set ON_DAMAGE_REF = LocalDamageEvent(this).ON_DAMAGE.reference(ON_DAMAGE)
						
						return true
					endif
					
					return false
				endmethod
				
				method disableDamageEventLocal takes nothing returns boolean
					if (count == 0) then
						return false
					endif
				
					set count = count - 1
				
					if (count == 0) then
						call ON_DAMAGE_REF.destroy()
						
						return true
					endif
					
					return false
				endmethod
			endif
		
			static if DamageEvent_FOUR_PHASE then
				static if thistype.onDamageOutgoing.exists then
					readonly Trigger ON_DAMAGE_OUTGOING
					private static boolexpr onDamageOutgoingExpr
					private TriggerReference ON_DAMAGE_OUTGOING_REF
					
					private static method onDamageOutgoingFunc takes nothing returns boolean
						call thistype(sourceId).onDamageOutgoing()
						return false
					endmethod
					
					private integer countOutgoing
					
					method enableDamageEventLocalOutgoing takes nothing returns boolean
						set countOutgoing = countOutgoing + 1
					
						if (countOutgoing == 1) then
							set ON_DAMAGE_OUTGOING_REF = LocalDamageEvent(this).ON_DAMAGE_OUTGOING.reference(ON_DAMAGE_OUTGOING)
							
							return true
						endif
						
						return false
					endmethod
					
					method disableDamageEventLocalOutgoing takes nothing returns boolean
						if (countOutgoing == 0) then
							return false
						endif
					
						set countOutgoing = countOutgoing - 1
					
						if (countOutgoing == 0) then
							call ON_DAMAGE_OUTGOING_REF.destroy()
							
							return true
						endif
						
						return false
					endmethod
				endif
				
				static if thistype.onDamageOutgoing.exists then
					private static method onUnitIndex takes nothing returns boolean
						local thistype this = UnitIndexer.eventIndex
					
						static if thistype.onDamage.exists then
							set ON_DAMAGE = Trigger.create(false)
							call ON_DAMAGE.register(onDamageExpr)
						endif
						
						static if thistype.onDamageOutgoing.exists then
							set ON_DAMAGE_OUTGOING = Trigger.create(false)
							call ON_DAMAGE_OUTGOING.register(onDamageOutgoingExpr)
						endif
						
						return false
					endmethod
					
					private static method onUnitDeindex takes nothing returns boolean
						local thistype this = UnitIndexer.eventIndex
						
						static if thistype.onDamage.exists then
							call ON_DAMAGE.destroy()
							
							set count = 0
						endif
						
						static if thistype.onDamageOutgoing.exists then
							call ON_DAMAGE_OUTGOING.destroy()
							
							set countOutgoing = 0
						endif
						
						return false
					endmethod
				elseif thistype.onDamage.exists then
					private static method onUnitIndex takes nothing returns boolean
						local thistype this = UnitIndexer.eventIndex
					
						static if thistype.onDamage.exists then
							set ON_DAMAGE = Trigger.create(false)
							call ON_DAMAGE.register(onDamageExpr)
						endif
						
						static if thistype.onDamageOutgoing.exists then
							set ON_DAMAGE_OUTGOING = Trigger.create(false)
							call ON_DAMAGE_OUTGOING.register(onDamageOutgoingExpr)
						endif
						
						return false
					endmethod
					
					private static method onUnitDeindex takes nothing returns boolean
						local thistype this = UnitIndexer.eventIndex
						
						static if thistype.onDamage.exists then
							call ON_DAMAGE.destroy()
							
							set count = 0
						endif
						
						static if thistype.onDamageOutgoing.exists then
							call ON_DAMAGE_OUTGOING.destroy()
							
							set countOutgoing = 0
						endif
						
						return false
					endmethod
				endif
				
				static if thistype.onDamageBefore.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onDamage.exists then
							set onDamageExpr = Condition(function thistype.onDamageFunc)
						endif
						
						static if thistype.onDamageOutgoing.exists then
							set onDamageOutgoingExpr = Condition(function thistype.onDamageOutgoingFunc)
						endif
						
						static if thistype.onDamage.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						elseif thistype.onDamageOutgoing.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						endif
						
						static if thistype.onDamageBefore.exists then
							set ON_DAMAGE_BEFORE = Trigger.create(false)
							call ON_DAMAGE_BEFORE.register(getCondition(function thistype.onDamageBefore))
							call GlobalDamageEvent.ON_DAMAGE_BEFORE.reference(ON_DAMAGE_BEFORE)
						endif
						
						static if thistype.onDamageAfter.exists then
							set ON_DAMAGE_AFTER = Trigger.create(true)
							call ON_DAMAGE_AFTER.register(getCondition(function thistype.onDamageAfter))
							call GlobalDamageEvent.ON_DAMAGE_AFTER.reference(ON_DAMAGE_AFTER)
						endif
					endmethod
				elseif thistype.onDamageAfter.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onDamage.exists then
							set onDamageExpr = Condition(function thistype.onDamageFunc)
						endif
						
						static if thistype.onDamageOutgoing.exists then
							set onDamageOutgoingExpr = Condition(function thistype.onDamageOutgoingFunc)
						endif
						
						static if thistype.onDamage.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						elseif thistype.onDamageOutgoing.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						endif
						
						static if thistype.onDamageBefore.exists then
							set ON_DAMAGE_BEFORE = Trigger.create(false)
							call ON_DAMAGE_BEFORE.register(getCondition(function thistype.onDamageBefore))
							call GlobalDamageEvent.ON_DAMAGE_BEFORE.reference(ON_DAMAGE_BEFORE)
						endif
						
						static if thistype.onDamageAfter.exists then
							set ON_DAMAGE_AFTER = Trigger.create(true)
							call ON_DAMAGE_AFTER.register(getCondition(function thistype.onDamageAfter))
							call GlobalDamageEvent.ON_DAMAGE_AFTER.reference(ON_DAMAGE_AFTER)
						endif
					endmethod
				elseif thistype.onDamage.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onDamage.exists then
							set onDamageExpr = Condition(function thistype.onDamageFunc)
						endif
						
						static if thistype.onDamageOutgoing.exists then
							set onDamageOutgoingExpr = Condition(function thistype.onDamageOutgoingFunc)
						endif
						
						static if thistype.onDamage.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						elseif thistype.onDamageOutgoing.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						endif
						
						static if thistype.onDamageBefore.exists then
							set ON_DAMAGE_BEFORE = Trigger.create(false)
							call ON_DAMAGE_BEFORE.register(getCondition(function thistype.onDamageBefore))
							call GlobalDamageEvent.ON_DAMAGE_BEFORE.reference(ON_DAMAGE_BEFORE)
						endif
						
						static if thistype.onDamageAfter.exists then
							set ON_DAMAGE_AFTER = Trigger.create(true)
							call ON_DAMAGE_AFTER.register(getCondition(function thistype.onDamageAfter))
							call GlobalDamageEvent.ON_DAMAGE_AFTER.reference(ON_DAMAGE_AFTER)
						endif
					endmethod
				elseif thistype.onDamageOutgoing.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onDamage.exists then
							set onDamageExpr = Condition(function thistype.onDamageFunc)
						endif
						
						static if thistype.onDamageOutgoing.exists then
							set onDamageOutgoingExpr = Condition(function thistype.onDamageOutgoingFunc)
						endif
						
						static if thistype.onDamage.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						elseif thistype.onDamageOutgoing.exists then
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						endif
						
						static if thistype.onDamageBefore.exists then
							set ON_DAMAGE_BEFORE = Trigger.create(false)
							call ON_DAMAGE_BEFORE.register(getCondition(function thistype.onDamageBefore))
							call GlobalDamageEvent.ON_DAMAGE_BEFORE.reference(ON_DAMAGE_BEFORE)
						endif
						
						static if thistype.onDamageAfter.exists then
							set ON_DAMAGE_AFTER = Trigger.create(true)
							call ON_DAMAGE_AFTER.register(getCondition(function thistype.onDamageAfter))
							call GlobalDamageEvent.ON_DAMAGE_AFTER.reference(ON_DAMAGE_AFTER)
						endif
					endmethod
				endif
			else
				static if thistype.onDamage.exists then
					private static method onUnitIndex takes nothing returns boolean
						local thistype this = UnitIndexer.eventIndex
					
						set ON_DAMAGE = Trigger.create(false)
						call ON_DAMAGE.register(onDamageExpr)
					
						return false
					endmethod
					
					private static method onUnitDeindex takes nothing returns boolean
						local thistype this = UnitIndexer.eventIndex
					
						call ON_DAMAGE.destroy()
						
						set count = 0
						
						return false
					endmethod
				endif
				
				static if thistype.onDamageBefore.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onDamage.exists then
							set onDamageExpr = Condition(function thistype.onDamageFunc)
							
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						endif
					
						static if thistype.onDamageBefore.exists then
							set ON_DAMAGE_BEFORE = Trigger.create(false)
							call ON_DAMAGE_BEFORE.register(getCondition(function thistype.onDamageBefore))
							call GlobalDamageEvent.ON_DAMAGE_BEFORE.reference(ON_DAMAGE_BEFORE)
						endif
						
						static if thistype.onDamageAfter.exists then
							set ON_DAMAGE_AFTER = Trigger.create(true)
							call ON_DAMAGE_AFTER.register(getCondition(function thistype.onDamageAfter))
							call GlobalDamageEvent.ON_DAMAGE_AFTER.reference(ON_DAMAGE_AFTER)
						endif
					endmethod
				elseif thistype.onDamageAfter.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onDamage.exists then
							set onDamageExpr = Condition(function thistype.onDamageFunc)
							
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						endif
					
						static if thistype.onDamageBefore.exists then
							set ON_DAMAGE_BEFORE = Trigger.create(false)
							call ON_DAMAGE_BEFORE.register(getCondition(function thistype.onDamageBefore))
							call GlobalDamageEvent.ON_DAMAGE_BEFORE.reference(ON_DAMAGE_BEFORE)
						endif
						
						static if thistype.onDamageAfter.exists then
							set ON_DAMAGE_AFTER = Trigger.create(true)
							call ON_DAMAGE_AFTER.register(getCondition(function thistype.onDamageAfter))
							call GlobalDamageEvent.ON_DAMAGE_AFTER.reference(ON_DAMAGE_AFTER)
						endif
					endmethod
				elseif thistype.onDamage.exists then
					private static method onInit takes nothing returns nothing
						static if thistype.onDamage.exists then
							set onDamageExpr = Condition(function thistype.onDamageFunc)
							
							call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onUnitIndex))
							call UnitIndexer.GlobalEvent.ON_DEINDEX.register(Condition(function thistype.onUnitDeindex))
						endif
					
						static if thistype.onDamageBefore.exists then
							set ON_DAMAGE_BEFORE = Trigger.create(false)
							call ON_DAMAGE_BEFORE.register(getCondition(function thistype.onDamageBefore))
							call GlobalDamageEvent.ON_DAMAGE_BEFORE.reference(ON_DAMAGE_BEFORE)
						endif
						
						static if thistype.onDamageAfter.exists then
							set ON_DAMAGE_AFTER = Trigger.create(true)
							call ON_DAMAGE_AFTER.register(getCondition(function thistype.onDamageAfter))
							call GlobalDamageEvent.ON_DAMAGE_AFTER.reference(ON_DAMAGE_AFTER)
						endif
					endmethod
				endif
			endif
        endmodule

        /*
        *   DDS Event Handling
        */
module DAMAGE_EVENT_RESPONSE_LOCALS
                local UnitIndex prevTarget = targetId_p
                local UnitIndex prevSource = sourceId_p
                
                local real prevDamage = damage_p
endmodule
module DAMAGE_EVENT_RESPONSE_BEFORE
                if (0 == GetEventDamage()) then
                    return
                endif
                
                set targetId_p = GetUnitUserData(GetTriggerUnit())
                set sourceId_p = GetUnitUserData(GetEventDamageSource())
                set damage_p = GetEventDamage()
                set sourcePlayer_p = GetOwningPlayer(sourceId_p.unit)
                set targetPlayer_p = GetOwningPlayer(targetId_p.unit)
endmodule
module DAMAGE_EVENT_RESPONSE
				static if DamageEvent_FOUR_PHASE then
					call LocalDamageEvent(sourceId_p).ON_DAMAGE_MAIN.fire()
					call LocalDamageEvent(targetId_p).ON_DAMAGE_MAIN_2.fire()
				else
					call LocalDamageEvent(targetId_p).ON_DAMAGE_MAIN.fire()
				endif
endmodule
module DAMAGE_EVENT_RESPONSE_AFTER
                
endmodule
module DAMAGE_EVENT_RESPONSE_CLEANUP
                set targetId_p = prevTarget
                set sourceId_p = prevSource
                set damage_p = prevDamage
				
				if (sourceId_p == 0) then
					set sourcePlayer_p = null
				else
					set targetPlayer_p = GetOwningPlayer(sourceId_p.unit)
				endif
				
				if (targetId_p == 0) then
					set sourcePlayer_p = null
				else
					set targetPlayer_p = GetOwningPlayer(targetId_p.unit)
				endif
endmodule
    endscope
    //! endtextmacro
endlibrary//===========================================================================
// Trigger: Damage Event Modification DDS Plugin
//===========================================================================
library DamageEventModification /* v1.1.0.0
*************************************************************************************
*
*   Damage Event Modification plugin for DDS
*
*************************************************************************************
*
*   */uses/*
*
*       */ DDS                      /*
*       */ DamageEvent              /*
*
*************************************************************************************
*
*   SETTINGS
*/
globals
    /*************************************************************************************
    *
    *   Configure to life bonus ability type id
    *
    *************************************************************************************/
    constant integer LIFE_SAVER_ABILITY_ID     = 'A001'
    constant integer LIFE_SAVER_ABILITY_ID_2   = 'A003'
    constant integer ARMOR_ABILITY_ID          = 'A004'
endglobals
/*
*************************************************************************************
*
*   API
*
*       static real damage
*           -   may now be changed
*       readonly static real damageOriginal
*           -   result of GetEventDamage()
*       readonly static real damageModifiedAmount
*           -   how much the damage variable was changed
*
*************************************************************************************
*
*   Plugin Information (can only be used by other plugins)
*
*       GLOBALS
*
*           boolean array saved
*               -   does the unit have life bonus
*
*           unit killUnit
*               -   a dummy unit that can be used to deal damage
*
*       LOCALS
*
*           real life
*               -   life of target unit
*
*           unit u
*               -   stores target, improved speed
*
*************************************************************************************/
    //! textmacro DAMAGE_EVENT_MODIFICATION_CODE
    private keyword saved
    private keyword killUnit
    
    private struct FixLife extends array
        static boolexpr exprKill
        static boolexpr exprLife
        
        private unit source
        private player sourcePlayer
        private real life
        private real damage
        
        static method funcKill takes nothing returns boolean
            local unit u = GetTriggerUnit()
            local thistype target = GetUnitUserData(u)
            local real maxLife = GetUnitState(UnitIndex(target).unit, UNIT_STATE_MAX_LIFE)
            
            call DestroyTrigger(GetTriggeringTrigger())
            
            set DDS[target].enabled = false
        
            call UnitAddAbility(u, ARMOR_ABILITY_ID)
            if (GetUnitTypeId(target.source) == 0) then
                call SetUnitX(killUnit, GetUnitX(u))
                call SetUnitY(killUnit, GetUnitY(u))
                call SetUnitOwner(killUnit, target.sourcePlayer, false)
                
                call SetWidgetLife(UnitIndex(target).unit, maxLife*.5)
                call UnitDamageTarget(killUnit, u, 10000000, false, true, null, DAMAGE_TYPE_UNIVERSAL, null)
                call SetWidgetLife(UnitIndex(target).unit, maxLife*.5)
                call UnitDamageTarget(killUnit, u, 10000000, false, true, null, DAMAGE_TYPE_NORMAL, null)
            else
                call SetWidgetLife(UnitIndex(target).unit, maxLife*.5)
                call UnitDamageTarget(target.source, u, 10000000, false, true, null, DAMAGE_TYPE_UNIVERSAL, null)
                call SetWidgetLife(UnitIndex(target).unit, maxLife*.5)
                call UnitDamageTarget(target.source, u, 10000000, false, true, null, DAMAGE_TYPE_NORMAL, null)
            endif
            call UnitRemoveAbility(u, ARMOR_ABILITY_ID)
            
            set DDS[target].enabled = true
            
            call SetWidgetLife(u, 0)
            
            set u = null
            
            return false
        endmethod
        
        static method funcLife takes nothing returns boolean
            local thistype target = GetUnitUserData(GetTriggerUnit())
            
            call DestroyTrigger(GetTriggeringTrigger())
            
            call SetWidgetLife(UnitIndex(target).unit, GetUnitState(UnitIndex(target).unit, UNIT_STATE_MAX_LIFE))
            call UnitRemoveAbility(UnitIndex(target).unit, LIFE_SAVER_ABILITY_ID)
            call UnitRemoveAbility(UnitIndex(target).unit, LIFE_SAVER_ABILITY_ID_2)
            call SetWidgetLife(UnitIndex(target).unit, target.life)
            
            return false
        endmethod
        
        static method applyKill takes thistype target, unit source, player sourcePlayer, real damage returns nothing
            local trigger t
            
            call SetWidgetLife(UnitIndex(target).unit, GetUnitState(UnitIndex(target).unit, UNIT_STATE_MAX_LIFE))
            
            set target.source = source
            set target.sourcePlayer = sourcePlayer
            
            set t = CreateTrigger()
            call TriggerRegisterUnitStateEvent(t, UnitIndex(target).unit, UNIT_STATE_LIFE, GREATER_THAN, GetWidgetLife(UnitIndex(target).unit)*.99)
            call TriggerAddCondition(t, exprKill)
            call SetWidgetLife(UnitIndex(target).unit, GetWidgetLife(UnitIndex(target).unit)*.99)
            
            set t = null
        endmethod
        
        static method applyLife takes thistype target, real life returns nothing
            local trigger t
            
            set target.life = life
            call SetWidgetLife(UnitIndex(target).unit, GetUnitState(UnitIndex(target).unit, UNIT_STATE_MAX_LIFE))
            if (GetWidgetLife(UnitIndex(target).unit) < 10) then
                call UnitAddAbility(UnitIndex(target).unit, LIFE_SAVER_ABILITY_ID_2)
            else
                call UnitAddAbility(UnitIndex(target).unit, LIFE_SAVER_ABILITY_ID)
            endif
            
            set t = CreateTrigger()
            if (GetEventDamage() < 0) then
                call TriggerRegisterUnitStateEvent(t, UnitIndex(target).unit, UNIT_STATE_LIFE, GREATER_THAN, GetWidgetLife(UnitIndex(target).unit)*.99)
                call SetWidgetLife(UnitIndex(target).unit, GetWidgetLife(UnitIndex(target).unit)*.99)
            else
                call TriggerRegisterUnitStateEvent(t, UnitIndex(target).unit, UNIT_STATE_LIFE, LESS_THAN, GetWidgetLife(UnitIndex(target).unit) - GetEventDamage()*.5)
            endif
            call TriggerAddCondition(t, exprLife)
            
            set t = null
        endmethod
    endstruct
    
    scope DamageEventModification
        globals
            unit killUnit
        endglobals
        
        /*
        *   DDS API
        *
        *       DDS.damage                  Can Now Be Set
        *       DDS.damageOriginal
        *       DDS.damageModifiedAmount
        *
        */
        module DAMAGE_EVENT_MODIFICATION_API
            readonly static real damageOriginal = 0
            
            static method operator damageModifiedAmount takes nothing returns real
                return damage_p - damageOriginal
            endmethod
            static method operator damage= takes real newDamage returns nothing
                set damage_p = newDamage
            endmethod
            
        endmodule
        module DAMAGE_EVENT_MODIFICATION_INIT
            set UnitIndexer.enabled = false
            set killUnit = CreateUnit(Player(15), 'hfoo', WorldBounds.maxX - 128, WorldBounds.maxY - 128, 0)
            set UnitIndexer.enabled = true
            
            call UnitAddAbility(killUnit, 'Aloc')
            call UnitAddAbility(killUnit, 'Avul')
            call ShowUnit(killUnit, false)
            call PauseUnit(killUnit, true)
            
            set FixLife.exprKill = Condition(function FixLife.funcKill)
            set FixLife.exprLife = Condition(function FixLife.funcLife)
        endmodule

        /*
        *   DDS Interface
        */
        module DAMAGE_EVENT_MODIFICATION_INTERFACE
            
        endmodule

        /*
        *   DDS Event Handling
        */
module DAMAGE_EVENT_MODIFICATION_RESPONSE_LOCALS
                local real actualDamage
                local real prevDamageOriginal = damageOriginal
                local real life
                local unit u
endmodule
module DAMAGE_EVENT_MODIFICATION_RESPONSE_BEFORE
                set actualDamage = damage_p
                set damageOriginal = actualDamage                   //original damage as seen by user
                set u = targetId_p.unit
endmodule
module DAMAGE_EVENT_MODIFICATION_RESPONSE
                
endmodule
module DAMAGE_EVENT_MODIFICATION_RESPONSE_AFTER
                set life = GetWidgetLife(u)
                
                if (actualDamage < 0) then
                    if (life - damage_p < .4051) then
                        call FixLife.applyKill(targetId_p, source, sourcePlayer_p, actualDamage)
                    elseif (life + actualDamage - damage_p < .406) then
                        call FixLife.applyLife(targetId_p, life - damage_p)
                    else
                        call SetWidgetLife(u, life + actualDamage - damage_p)
                    endif
                elseif (life - damage_p < .4051) then
                    call SetWidgetLife(u, actualDamage)
                elseif (life + actualDamage - damage_p > GetUnitState(u, UNIT_STATE_MAX_LIFE)) then
                    call FixLife.applyLife(targetId_p, life + actualDamage - damage_p)
                else
                    call SetWidgetLife(u, life + actualDamage - damage_p)
                endif
endmodule
module DAMAGE_EVENT_MODIFICATION_RESPONSE_CLEANUP
                set damageOriginal = prevDamageOriginal
                set u = null
endmodule        
    endscope
    //! endtextmacro
endlibrary//===========================================================================
// Trigger: Damage Event Archetype DDS Plugin
//===========================================================================
library DamageEventArchetype /* v1.0.2.0
*************************************************************************************
*
*   Damage Event Archetype plugin for DDS
*
*
*   Notes
*   --------------
*
*       -   Must invert Damage Return Factor for Locust Swarm based abilities
*
*       -   Must invert healing portion of Life Drain based abilities
*
*************************************************************************************
*
*   */uses/*
*
*       */ DDS                      /*      hiveworkshop.com/forums/spells-569/framework-dds-damage-detection-system-231238/
*       */ DamageEventModification  /*      hiveworkshop.com/forums/jass-resources-412/dds-plugin-damage-event-modification-231176/
*
************************************************************************************
*
*   SETTINGS
*/
globals
    /*************************************************************************************
    *
    *   Configure to spell reduction ability type id
    *
    *************************************************************************************/
    constant integer DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY = 'A002'
endglobals
/*
*************************************************************************************
*
*   API
*
*       static constant integer Archetype.SPELL
*       static constant integer Archetype.PHYSICAL
*       static constant integer Archetype.CODE
*
*       readonly static integer archetype
*           -   type of damage source damage came from: SPELL, PHYSICAL, CODE
*
*       static UnitIndex damageCode
*           -   set this to the unit that will be damaged with code
*
*       seals (can no longer be overwritten)
*
*           boolean enabled (from DDS Framework)
*
*************************************************************************************/
    //! textmacro DAMAGE_EVENT_ARCHETYPE_CODE
    globals
        private constant boolean ENABLED_EXISTS = true
        
        private real scale
    endglobals
    
    scope Archetype
        private struct DamageEventArchtype extends array
            static constant integer SPELL = 0
            static constant integer PHYSICAL = 1
            static constant integer CODE = 2
        endstruct
    
        /*
        *   DDS API
        *
        *       DDS.Archetype.SPELL
        *       DDS.Archetype.PHYSICAL
        *       DDS.Archetype.CODE
        *       DDS.archetype
        *       DDS.damageCode
        *       
        */
            private keyword archetype_p
            private keyword damageEventArchetypeInit
            private keyword damageCode_p
            module DAMAGE_EVENT_ARCHETYPE_API
                readonly static DamageEventArchtype Archetype = 0
                static integer archetype_p = 0
                static UnitIndex damageCode_p = 0
                
                static method operator damageCode= takes UnitIndex u returns nothing
                    set damageCode_p = u
                endmethod
                static method operator damageCode takes nothing returns UnitIndex
                    return damageCode_p
                endmethod
                
                static method operator archetype takes nothing returns integer
                    return archetype_p
                endmethod
                
                private static method onIndex takes nothing returns boolean
                    call UnitAddAbility(UnitIndexer.eventUnit, DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY)
                    call UnitMakeAbilityPermanent(UnitIndexer.eventUnit, true, DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY)
                    
                    return false
                endmethod
                
                static method damageEventArchetypeInit takes nothing returns nothing
                    local integer playerId
            
                    set playerId = 15
                    loop
                        call SetPlayerAbilityAvailable(Player(playerId), DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY, false)
                        
                        exitwhen 0 == playerId
                        set playerId = playerId - 1
                    endloop
                
					call UnitIndexer.GlobalEvent.ON_INDEX.register(Condition(function thistype.onIndex))
                endmethod
            endmodule
            module DAMAGE_EVENT_ENABLE
                method operator enabled= takes boolean b returns nothing
                    if (b) then
                        call EnableTrigger(RefreshTrigger(this).parent.trigger)
                        call UnitAddAbility(UnitIndex(this).unit, DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY)
                        call UnitMakeAbilityPermanent(UnitIndex(this).unit, true, DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY)
                    else
                        call DisableTrigger(RefreshTrigger(this).parent.trigger)
                        call UnitRemoveAbility(UnitIndex(this).unit, DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY)
                    endif
                endmethod
            endmodule
            module DAMAGE_EVENT_ARCHETYPE_INIT
                call DDS.damageEventArchetypeInit()
            endmodule

        /*
        *   DDS Interface
        */
        module DAMAGE_EVENT_ARCHETYPE_INTERFACE
            
        endmodule

        /*
        *   DDS Event Handling
        */
module DAMAGE_EVENT_ARCHETYPE_RESPONSE_LOCALS
                local integer prevArchetype = archetype_p
endmodule
module DAMAGE_EVENT_ARCHETYPE_RESPONSE_BEFORE
                if (damage_p < 0) then
                    set archetype_p = Archetype.SPELL
                    
                    /*
                    *   Calculate spell resistance
                    */
                    call DisableTrigger(RefreshTrigger(targetId_p).parent.trigger)
                    
                        set life = GetWidgetLife(u)
                        set scale = GetUnitState(u, UNIT_STATE_MAX_LIFE)
                        call SetWidgetLife(u, scale)
                        call UnitDamageTarget(killUnit, u, -scale/2, false, false, null, DAMAGE_TYPE_UNIVERSAL, null)
                        set scale = 2*(scale - GetWidgetLife(u))/scale
                        if (scale > 1) then
                            set damageOriginal = -damageOriginal*scale
                        else
                            set damageOriginal = -damageOriginal
                        endif
                        call SetWidgetLife(u, life)
                    
                    call EnableTrigger(RefreshTrigger(targetId_p).parent.trigger)
                    
                    set damage_p = damageOriginal
                else
                    set archetype_p = Archetype.PHYSICAL
                endif

                if (damageCode_p != 0) then
                    set archetype_p = Archetype.CODE
                    set damageCode_p = 0
                endif
endmodule
module DAMAGE_EVENT_ARCHETYPE_RESPONSE
                
endmodule
module DAMAGE_EVENT_ARCHETYPE_RESPONSE_AFTER
                
endmodule
module DAMAGE_EVENT_ARCHETYPE_RESPONSE_CLEANUP
                set archetype_p = prevArchetype
endmodule
    endscope
    //! endtextmacro
endlibrary//===========================================================================
// Trigger: Type
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
library Type /* v1.0.0.0
*************************************************************************************
*
*   Type checking
*
*************************************************************************************
*
*   struct Type extends array
*
*       static method create takes Type parent returns Type
*           -   Creates a new type given a parent
*
*       method extends takes Type type returns boolean
*           -   A.extends(B) checks if A extends B (B parent of A)
*       method isParent takes Type type returns boolean
*           -   A.isParent(B) checks if A is a parent of B (B extends A)
*
*************************************************************************************/
    struct Type extends array
        private static integer instanceCount = 0
        private static hashtable parentTable = InitHashtable()
        private Type parent
        
        static method create takes Type parent returns Type
            local thistype this = instanceCount + 1
            set instanceCount = this
            
            call SaveBoolean(parentTable, this, this, true)
            call SaveBoolean(parentTable, this, 0, true)
            
            set this.parent = parent
            loop
                exitwhen parent == 0
                call SaveBoolean(parentTable, this, parent, true)
                set parent = thistype(parent).parent
            endloop
            
            return instanceCount
        endmethod
        
        method extends takes Type t returns boolean
            return HaveSavedBoolean(parentTable, this, t)
        endmethod
        method isParent takes Type t returns boolean
            return HaveSavedBoolean(parentTable, t, this)
        endmethod
    endstruct
endlibrary//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_AllocQ(  )
    call InitTrig_AllocT(  )
    call InitTrig_ListNx(  )
    call InitTrig_NxStackT(  )
    call InitTrig_ListT(  )
    call InitTrig_Table(  )
    call InitTrig_NxStack(  )
    call InitTrig_NxListT(  )
    call InitTrig_UniqueNxListT(  )
    call InitTrig_WorldBounds(  )
    call InitTrig_ErrorMessage(  )
    call InitTrig_Init(  )
    call InitTrig_TableField(  )
    call InitTrig_Trigger_Refresh(  )
    call InitTrig_BooleanExpression(  )
    call InitTrig_Trigger(  )
    call InitTrig_UnitIndexer_Settings(  )
    call InitTrig_UnitIndexer(  )
    call InitTrig_UnitIndexer_UnitIndex(  )
    call InitTrig_UnitIndexer_UnitIndexer(  )
    call InitTrig_UnitIndexer_Pregame_Event(  )
    call InitTrig_DDS(  )
    call InitTrig_Damage_Event_DDS_Plugin(  )
    call InitTrig_Damage_Event_Modification_DDS_Plugin(  )
    call InitTrig_Damage_Event_Archetype_DDS_Plugin(  )
    call InitTrig_Type(  )
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), true )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_002
    call SetPlayerTeam( Player(0), 0 )

endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -1280.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -1536.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -1280.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 5120.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 5376.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -1536.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "LordaeronSummerDay" )
    call SetAmbientNightSound( "LordaeronSummerNight" )
    call SetMapMusic( "Music", true, 0 )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName( "TRIGSTR_017" )
    call SetMapDescription( "TRIGSTR_019" )
    call SetPlayers( 1 )
    call SetTeams( 1 )
    call SetGamePlacement( MAP_PLACEMENT_USE_MAP_SETTINGS )

    call DefineStartLocation( 0, 1152.0, 832.0 )

    // Player setup
    call InitCustomPlayerSlots(  )
    call SetPlayerSlotAvailable( Player(0), MAP_CONTROL_USER )
    call InitGenericPlayerSlots(  )
endfunction

